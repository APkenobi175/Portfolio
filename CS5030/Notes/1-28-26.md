# CS5030 - Class 7 - 1/28/26 Notes

## Announcements

- Wait for an email from University of Utah about CHCP Account. THis will let you use a super computer for free.

### Review 

- Last class we talked about pthreads and c++11 threads.
- We talked about how to dynamically use threads to speed up a computation
- We also talked about a special variable type called a mutex
  - A mutex is a variable that can be locked and unlocked
  - This allows multiple threads to safely access shared data without causing a race condition
  - This also eliminates the need for critical sections and busy waiting


### Mutex Continued

- Whats the difference between mutex and busy waiting?
  - Busy waiting is when a thread continuously checks a condition until it is met
  - This can waste CPU cycles and lead to inefficiency
  - A mutex, on the other hand, allows a thread to block until the mutex is available, which is more efficient
  - A mutex will sleep the thread, busy waiting will keep the thread active, so that saves CPU cycles for other threads to use
  - Busy wait forces an order, mutex does not force an order so threads can complete in any order. But order doesn't always matter. Sometimes, it does 
  - When order matters, busy waiting is better for us

- Busy Wait Example:

    ```c
    flag = 0;
    long my_rank = (long) rank;
    while (flag != my_rank){
        sum += my_sum;
        flag = (flag + 1) % num_threads;
    }
    ```

- Mutex Example:

    ```c
    void* Thread_work(void* rank){
        long my_rank = (long) rank;
        matrix_t my_mat = Allocate_matrix(n);
        Generate_matrix(my_mat);
        pthread_mutex_lock(&mutex);
        Add_matrix(A, my_mat);
        pthread_mutex_unlock(&mutex);
        Free_matrix(my_mat);
        return NULL;
    }
    ```

- IN this example, each thread generates its own matrix, which is good. Then, in the critical section, it adds its matrix to a shared matrix A. The mutex ensures that only one thread can access the shared matrix at a time. This prevents race conditions and ensures that the final result is correct.

- Threads can access other threads's data. These variables are gloval variables. Each thread has its own stack, but they share the heap and global variables.

- my_rank is what identifies the thread.


- Can we use a mutex to ensure every thread gets its message?

    ```c
    pthread_mutex_lock[&mutex[dest]];
    messages[dest] = my_msg;
    pthread_mutex_unlock[&mutex[dest]];

    pthread_mutex_lock[&mutex[my_rank]];
    printf("Thread %ld > message = %d\n", my_rank, messages[my_rank]);
    ```

- What can happen here?
  - A deadlock can happen here because once we do this, a thread will never be able to read its message because it is waiting for another thread to write its message, which is waiting for the first thread to read its message. This is a circular wait.

- Another method we can use, Semaphores
  - Semaphores are not part of Pthreads you have to import them separately

```c
#include <semaphore.h>
int sem_init(
    sem_t* semaphore_p /*out*/,
    int shared /* in*/,
    unsigned initial_val /* in */
)

int sem_destroy(sem_t* semaphore_p /* in/out */)
int sem_post(sem_t* semaphore_p /* in/out */)
int sem_wait(sem_t* semaphore_p /* in/out */)
```

- sem_init initializes a semaphore
  - shared is 0 if the semaphore is only used by threads in the same process
  - initial_val is the initial value of the semaphore
- sem_destroy destroys a semaphore
- sem_post increments the semaphore value
- sem_wait decrements the semaphore value, if the value is 0, the thread will block until the value is greater than 0

- This allows us to do the same thing as a mutex, but with more flexibility. We can have multiple threads access the same resource at the same time up to a limit, which is defined by the initial value of the semaphore.

```c
sprintf(msg, "Hello from thread %ld", my_rank);
sem_post(&semaphores[dest]); // this signals that the message from the thread is ready
sem_wait(&semaphores[my_rank]); // this waits until the message for this thread is ready
printf("Thread %ld > message = %s\n", my_rank, messages[my_rank]);
```

- In this example, each thread writes its message and then signals that the message is ready using sem_post. Then, it waits for its own message to be ready from the other threads using sem_wait. This prevents deadlock because each thread is only waiting for its own message to be ready.

### Barriers and Condition Variables

#### Barriers

- Synchronizing the threads to make sure that they are all at the same point in the program before proceeding, is called a **barrier**.
  - When could this be useful?
    - TO make it so a program will run the same regardless of how many threads are used.
    - For example, if you have a program that does some computation in parallel, and then does some computation that depends on the results of the first computation, you want to make sure that all threads have finished the first computation before proceeding to the second computation.
    - In this case, a barrier can be used to synchronize the threads at the end of the first computation, ensuring that they all wait for each other before moving on to the second computation.
    - This way the second computation can't execute if its not ready too. THe second computation could execute correctly sometimes, but not always if we don't put a barrier in place.
- You can also use barriers for timing the slowest thread
- You can also use barriers for debugging

    ```c
    if (my_rank == 0){
        prnintf("All threads have reached the barrier\n");
        fflush(stdout); // make sure the output is printed before proceeding
    }
    ```

- One thing he has seen is your program doesn't work, and then you put a barrier, and then it works all of a sudden. This is because the barrier forces the threads to synchronize, which can change the timing of the program and make it work.

- A barrier is not free, it includes waiting.

- You can implement a barrier using busy-waiting and a mutex.
  - We use shared counter variable to count how many threads have reached the barrier.

```c
coid* thread_work({
    pthread_mutex_lock(&barrier_mutex);
    counter++;
    pthread_mutex_unlock(&barrier_mutex);
    while (counter < num_threads){
        // busy wait
    }
    return NULL;
})
```

- The while loop waits until every thread has reached the counter++ line.

- YOu can also use semaphores, which might be slightly more efficient

```c
sem_t count_sem;
sem_t barrier_sem;

void* thread_work(){
sem_wait(&count_sem);
if (count == thread_count - 1){
    counter = 0;
    sem_post(&barrier_sem); // release the barrier
    for (j = 0; j < thread_count - 1; j++){
        sem_post(&barrier_sem); // release all other threads

    }else{
        counter ++;
        sem_post(&count_sem);
        sem_wait(&barrier_sem); // wait for the barrier to be released
    }
}
```

- So, each thread waits on the count_sem semaphore to access the counter variable. When the last thread reaches the barrier, it resets the counter and releases the barrier by posting to the barrier_sem semaphore. All other threads wait on the barrier_sem semaphore until it is released. $barrier_sem will only be released when count == thread_count - 1, which means all threads have reached the barrier.

- The last thread is the one who will do the if condition. It is the one that will release the barrier. 

- Review:
  - sem_wait decrements the semaphore, if the value is 0, the thread will block until the value is greater than 0
  - sem_post increments the semaphore value

- You will generally not use semaphores for barriers.
- It is a good example to see though because it uses everything we've talked about to implement a barrier.

#### Condition Variables

- This is something you find in C++
- You import it using `#include <condition_variable>`
- For example, in an ATM application, you need to add money before you withdraw money. You can use a condition variable to make sure that the withdraw function waits until there is enough money in the account before proceeding.

```c++
std::condition_variable cv;

cv.wait(ul, [] { return condition; });
```

- The cv variable is a conditional variable. and the cv.wait function takes a unique lock and a lambda function that returns a boolean value. The thread will wait until the lambda function returns true, which is what we define our condition as.







