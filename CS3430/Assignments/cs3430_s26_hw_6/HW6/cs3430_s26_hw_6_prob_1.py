"""
Problem 1 Write Up
Ammon Phipps

1) Why do the P-values fluctuate dramatically in the 10-50 digit regime?

    My Results:
        --------------------------------------------------------------------------------
        Num Digits | PI P-VAL     | E P-VAL     | Chi^2 PI Reject | Chi^2 E Reject
        --------------------------------------------------------------------------------
            10 |     0.534146 |    0.0668816 | False          | False         
            20 |     0.911413 |     0.834308 | False          | False         
            30 |     0.602458 |     0.739918 | False          | False         
            40 |     0.875539 |     0.689019 | False          | False         
            50 |     0.739918 |     0.911413 | False          | False         
            60 |     0.739918 |     0.602458 | False          | False         
            70 |     0.821681 |     0.247472 | False          | False         
            80 |     0.811993 |     0.330628 | False          | False         
            90 |     0.739918 |     0.447593 | False          | False        

    In the 10-50 digit regime the p values fluctate more because the expected count E_k = n/10 is less than 5 for the first 50 digits. 
    When the expected count is less than 5 the chi square approximation is unreliable. 


2) Why does the test occasionally reject H0 even though pi and e are generated by deterministic algorithms?

    My Results:
            3600 |    0.0786208 |     0.839603 | False          | False         
            3700 |    0.0493975 |     0.908543 | True           | False         
            3800 |     0.101725 |     0.924396 | False          | False
    
    My test contained one rejection of H0 for pi at 3700 digits. P-values still fluctuate after 50 digits, but they are more stable. However, 
    there are still occasional dips below the alpha = 0.05. Since the chi square test is a asymptotic test, it is just an approximation.
    Each new block of digits is a new sample which changes the empirical distribution. Because of this, we can get a low p-value by chance even if the digits are random.

    With an alpha of 0.05 this is expected to happen about 5% of the time, even if the digits are truly random.

3) Does failing to reject H0 prove that the digits are random? Explain carefully.

    No, failing to reject H0 does not prove that the digits are random. The same way that failing to reject the null hypothesis does not prove that it is true
    it only means that we do not have enough evidence to reject it, and that evidence is based on the alpha that we set.

    When our alpha is 0.05 not only is it the threshold for rejecting H0, but it also tells us the probabiliy of rejecting H0, when H0 is true.

4) If you perform many hypothesis tests at alpha=0.05, what fraction of rejections should you expect purely by chance?

    Performing many hypothesis tests at alpha 0.05 should yeild a 5% rejection rate purely by chance. The alpha level is the threashold for rejecting the null hypothesis
    and it also represents the probability of rejecting the null hypothesis even when it is true.

5) In what sense can a deterministic sequence behave statistically like a random one?

    A deterministic sequence can behave statistically like a random one if its distribution of digits behaves like a random sequence. 
    for example, if the digits of pi and e are uniformly distributed and independent, then they can be considered to behave statistically like random sequences.

"""

# cs3430_s26_hw_6_prob_1.py
# ---------------------------------------------------------------------------------------
#
# CS3430 S26: Scientific Computing
# HW 6, Problem 1: Chi-Square Goodness-of-Fit Tests on Mantissa Digits of pi and e
#
# Copyright (C) Vladimir Kulyukin. All rights reserved.
# For personal study by my students enrolled in CS3430 S26: Scientific Computing, SoC, CoE, USU.
# No redistribution or online posting (e.g., Course Hero, Chegg, GitHub, ChatGPT, Gemini,
# Co-Pilot, Claude, DeepSeek, public drives, any LLMs) without prior written permission.
#
# We test the decimal digit distribution (0–9) of the first Y mantissa digits of pi and e.
# This is a K=10 categorical chi-square goodness-of-fit test with df = K-1 = 9.
#
# IMPORTANT RELIABILITY CAVEAT:
# A common rule-of-thumb for the chi-square approximation is that each expected count
# should be at least 5:
#   E_k = Y/10 >= 5   ==>   Y >= 50.
# Therefore, for Y < 50, the chi-square approximation is technically unreliable.
# We DO NOT block execution for Y < 50. Why? Because I want you to see/experience
# instability at small samples.
#
# You know the drill: Read the code and replace # YOUR CODE HERE with your code blocks.
# I also left #TODO: annotators next to the functions that contain # YOUR CODE HERE. 
# ---------------------------------------------------------------------------------------

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Sequence

from collections import Counter

try:
    # SciPy is the intended tool for computing chi-square p-values.
    from scipy.stats import chi2  # type: ignore
except Exception as e:  # pragma: no cover
    chi2 = None         # type: ignore

# ---------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------

# The category set is decimal digits: 0..9
K_DIGITS: int = 10

# Degrees of freedom for K=10 categories is K-1 = 9.
DF_DIGITS: int = K_DIGITS - 1

# Default significance level used in the decision rule.
DEFAULT_ALPHA: float = 0.05

def hw6_y_values() -> List[int]:
    """
    Return the exact list of Y values (number of mantissa digits) to test.

    Required Y values:
      10, 20, ..., 100, 200, 300, ..., 9900, 9999

    Returns
    -------
    List[int]
        A list of the required prefix lengths in increasing order.

    Notes
    -----
    I separated this into its own function so that:
      (1) unit tests can verify the exact intended schedule, and
      (2) we can change it in one place if needed for more testing.
    """
    y_vals: List[int] = []

    # 10..100 step 10
    y_vals.extend(list(range(10, 101, 10)))

    # 200..9900 step 100
    y_vals.extend(list(range(200, 9901, 100)))

    # Final special value
    y_vals.append(9999)

    return y_vals

def digit_counts(digits: str) -> Dict[int, int]:
    """
    Count decimal digits (0..9) in a string.

    Parameters
    ----------
    digits : str
        A string that should contain only characters '0'..'9'.
        (If non-digits appear, we raise an error to keep the computation honest.)

    Returns
    -------
    Dict[int, int]
        A dictionary mapping each digit d in {0,..,9} to its observed count.

    Rationale
    --------------------
    In the chi-square goodness-of-fit test, we need observed counts O_k for each category.
    Here the categories are digits, so O_k is how many times digit k appears in the sample.

    Implementation notes
    --------------------
    We return counts for ALL digits 0..9, including zeros for digits that do not appear.
    This makes downstream code (chi-square statistic computation) simpler and safer. That's
    my hope anyaway!
    """
    if not isinstance(digits, str):
        raise TypeError("digits must be a str")

    # Enforce the intended input type: digit characters only.
    for ch in digits:
        if not ch.isdigit():
            raise ValueError(f"Non-digit character found: {repr(ch)}")

    c: Counter[str] = Counter(digits)

    # Ensure every digit 0..9 is present as a key, even if the count is 0.
    counts: Dict[int, int] = {d: 0 for d in range(K_DIGITS)}
    for d in range(K_DIGITS):
        counts[d] = int(c.get(str(d), 0))

    return counts

#TODO:
def chi_square_statistic(counts: Dict[int, int], n: int, k: int = K_DIGITS) -> float:
    """
    Compute the chi-square goodness-of-fit statistic for categorical counts.

    Null hypothesis (here):
        H0: P(digit = k) = 1/10 for k=0..9, and trials are i.i.d. (independent and
        identically distibuted).

    Statistic:
        chi^2 = sum_{k=0}^{K-1} (O_k - E_k)^2 / E_k
    where:
        O_k is observed count for category k,
        E_k = n * p_k is expected count,
        p_k = 1/K under the uniform null model.

    Parameters
    ----------
    counts : Dict[int, int]
        Dictionary mapping category index -> observed count.
        For our digit test, categories are 0..9.
    n : int
        Total sample size (number of digits).
    k : int
        Number of categories. For digits, k=10.

    Returns
    -------
    float
        The chi-square statistic value.

    Important notes on reliability
    -----------------------------
    The chi-square approximation is generally considered reliable only when
    all expected counts are sufficiently large (often >= 5).
    Here E_k = n/k. For digits: E_k = n/10.
    So a rule-of-thumb is: n >= 50 for this test.

    We do not enforce n >= 50 to see the instability at small n.

    Error handling
    --------------
    - Raises ValueError if n <= 0.
    - Raises ValueError if counts do not sum to n.
    - Raises ValueError if any category key is missing.
    """
    if not isinstance(n, int):
        raise TypeError("n must be an int")
    if n <= 0:
        raise ValueError("n must be positive")

    # Make sure all category keys 0..k-1 exist. Missing keys are a bug.
    for cat in range(k):
        if cat not in counts:
            raise ValueError(f"Missing category key in counts: {cat}")

    total: int = sum(int(counts[cat]) for cat in range(k))
    if total != n:
        raise ValueError(f"Counts sum to {total}, but n is {n}")

    # this is our mathematical expectation.
    expected: float = n / float(k)  # E_k under uniform null

    # expected will never be 0 because n>0 and k>=1, but we keep logic explicit.
    if expected <= 0.0:
        raise ValueError("Expected count must be positive")

    # 1) Initialize the chi-square statistic accumulator.
    # This variable will store the sum:
    #     sum_{i=1}^{k} (O_i - E_i)^2 / E_i
    # where:
    #   O_i = observed count for category i
    #   E_i = expected count under the null hypothesis
    chi_sq: float = 0.0

    # Iterate over all k categories (e.g., digits 0–9 for decimal data).
    # We assume categories are indexed 0, 1, ..., k-1.
    for cat in range(k):
        # 1) Retrieve the observed count for this category.
        # counts[cat] is assumed to exist for every category.
        # Convert explicitly to float to avoid unintended integer arithmetic.
        # get the counts[cat], convert it to float and save it in the
        # variable obs (observed)
        #

        obs: float = float(counts[cat])

        # 2) Compute deviation of obs from expected count under the null hypothesis
        # and save it in the variable diff (difference). In other words, we
        # do the Python equivalent of diff = O_i - E_i.
        #
        diff: float = obs - expected

        # 3) Add this category's contribution to the chi-square statistic:
        #
        #   (O_i - E_i)^2 / E_i
        #
        # Squaring penalizes large deviations symmetrically (positive or negative).
        # Dividing by expected scales the deviation relative to its variance
        # under the multinomial model.
        # So, we add the difference squared divided by expected to chi_sq
        #
        chi_sq += diff * diff / expected

    # After summing over all categories,
    # return the total chi-square test statistic.
    return chi_sq

# TODO:
def chi_square_p_value(chi_sq: float, df: int) -> float:
    """
    Compute the right-tail p-value for a chi-square test statistic.

    For a chi-square goodness-of-fit test:
        p = P(ChiSquare_df >= observed_chi_sq)

    This is inherently one-sided: large chi-square indicates large deviation.

    Parameters
    ----------
    chi_sq : float
        Observed chi-square statistic.
    df : int
        Degrees of freedom (for digits: df=9).

    Returns
    -------
    float
        Right-tail p-value in [0, 1].

    Requirements / Dependencies
    ---------------------------
    This function uses SciPy:
        from scipy.stats import chi2
        p = chi2.sf(chi_sq, df=df)

    If SciPy is not available, we raise an informative ImportError.
    This is better software engineering. Tells the user to install SciPy.
    I should have done it in the earlier assignments. Daahhhhh!
    """
    if not isinstance(df, int):
        raise TypeError("df must be an int")
    if df <= 0:
        raise ValueError("df must be positive")
    if chi_sq < 0:
        raise ValueError("chi_sq must be non-negative")

    if chi2 is None:
        raise ImportError(
            "scipy is required for chi-square p-values in this homework. "
            "Install scipy."
        )

    # 1) Compute the p-value using the chi-square survival function (sf).
    #
    # chi2.sf(x, df) computes:
    #
    #     P(ChiSquare_df >= x)
    #
    # i.e., the right-tail probability.
    #
    # This is exactly the p-value for a chi-square goodness-of-fit test:
    # the probability, under H0, of observing a statistic at least as
    # extreme as chi_sq.
    #
    # We compute p_val by explicitly casting to float chi2.sf(chi_sq, df=df)
    # to avoid returning a NumPy scalar. Rememer sf -- survival function.
    #
    p_val: float = float(chi2.sf(chi_sq, df=df))

    # 2) In exact mathematics, the survival function always returns
    # a value in the closed interval [0, 1].
    #
    # However, due to floating-point rounding error in extreme cases
    # (very large chi_sq or very small tail probabilities),
    # numerical libraries can sometimes return values slightly
    # outside this range (e.g., -1e-16 or 1.0000000002).
    #
    # To control for this, we defensively clamp the result to ensure it
    # remains a valid probability.
    if p_val < 0.0:
        p_val = 0.0

    if p_val > 1.0:
        p_val = 1.0
        
    # Return the final p-value.
    # Interpretation:
    #   - Small p-value  → statistic is unlikely under H0
    #   - Large p-value  → statistic is compatible with H0
    return p_val

# TODO:
def chi_square_decision(p_value: float, alpha: float = DEFAULT_ALPHA) -> bool:
    """
    Decision rule for a hypothesis test based on a p-value.

    Rule:
        Reject H0 if p_value <= alpha
        Fail to reject H0 otherwise.

    Parameters
    ----------
    p_value : float
        The p-value computed from the test statistic under H0.
    alpha : float
        Significance level (default 0.05).

    Returns
    -------
    bool
        True  => Reject H0
        False => Fail to reject H0

    Rationale
    --------
    - Rejecting H0 suggests the data are inconsistent with the null model.
    - Failing to reject H0 does NOT prove the data are random.
      It only means this test did not detect the targeted deviation.
    """
    if not isinstance(alpha, (int, float)):
        raise TypeError("alpha must be numeric")
    if alpha <= 0.0 or alpha >= 1.0:
        raise ValueError("alpha must be in (0, 1)")

    if not isinstance(p_value, (int, float)):
        raise TypeError("p_value must be numeric")
    if p_value < 0.0 or p_value > 1.0:
        raise ValueError("p_value must be in [0, 1]")

    # We return a boolean testing if p_value <= alpha.
    return p_value <= alpha


### Let me freeze this structure. No changes needed once computed.
@dataclass(frozen=True)
class ChiSquareRow:
    """
    One row of results for a particular prefix length Y.

    Fields
    ------
    num_digits : int
        The number of mantissa digits used (Y).
    pi_p_value : float
        p-value for pi digits under uniform digit null.
    e_p_value : float
        p-value for e digits under uniform digit null.
    pi_reject : bool
        Decision for pi: True means reject H0 at alpha.
    e_reject : bool
        Decision for e: True means reject H0 at alpha.
    """
    num_digits: int
    pi_p_value: float
    e_p_value: float
    pi_reject: bool
    e_reject: bool


def run_chi_square_experiments(
    pi_reference_filename: str,
    e_reference_filename: str,
    y_values: Sequence[int],
    alpha: float = DEFAULT_ALPHA,
) -> List[ChiSquareRow]:
    """
    Run chi-square goodness-of-fit experiments for pi and e mantissa digits.

    Workflow
    --------
    For each Y in y_values:
      1) Parse first Y mantissa digits of pi from pi_reference_filename.
      2) Parse first Y mantissa digits of e from e_reference_filename.
      3) Compute digit counts for each.
      4) Compute chi-square statistic with K=10 categories.
      5) Compute p-value using df=9.
      6) Apply decision rule at significance alpha.
      7) Store results in a ChiSquareRow.

    Parameters
    ----------
    pi_reference_filename : str
        Path to the pi digits reference file (contains "3." then digits).
    e_reference_filename : str
        Path to the e digits reference file (contains "2." then digits).
    y_values : Sequence[int]
        Prefix sizes (numbers of digits) to test.
    alpha : float
        Significance level for decisions.

    Returns
    -------
    List[ChiSquareRow]
        A list of result rows, one per Y, in the same order as y_values.

    Important note (Deterministic data, stochastic null)
    ----------------------------------------------------
    The mantissa digits of pi and e are deterministic sequences.
    We are evaluating whether their empirical digit frequency behavior
    is statistically consistent with the stochastic null model:
      i.i.d. Uniform({0,...,9}).

    Dependencies
    ------------
    This function imports the parsers from:
      - pi_mantissa_parser.py : parse_pi_mantissa
      - e_mantissa_parser.py  : parse_e_mantissa
    which are assumed to be provided as part of the HW 6 distribution.
    """
    # Local imports so unit tests can import this file even if parsers are absent
    # in some isolated environments. In the course environment, these modules exist.
    try:
        from pi_mantissa_parser import parse_pi_mantissa  # type: ignore
    except Exception as e:
        raise ImportError(
            "Could not import parse_pi_mantissa from pi_mantissa_parser.py. "
            "Make sure pi_mantissa_parser.py is present and importable."
        ) from e

    try:
        from e_mantissa_parser import parse_e_mantissa  # type: ignore
    except Exception as e:
        raise ImportError(
            "Could not import parse_e_mantissa from e_mantissa_parser.py. "
            "Make sure e_mantissa_parser.py is present and importable."
        ) from e

    if not isinstance(pi_reference_filename, str):
        raise TypeError("pi_reference_filename must be a str")
    if not isinstance(e_reference_filename, str):
        raise TypeError("e_reference_filename must be a str")

    # Validate alpha early.
    _ = chi_square_decision(0.5, alpha=alpha)  # type: ignore[arg-type]

    results: List[ChiSquareRow] = []

    for y in y_values:
        if not isinstance(y, int):
            raise TypeError("All y_values must be ints")
        if y <= 0:
            raise ValueError("All y_values must be positive")

        # Parse exactly y digits of each mantissa.
        pi_digits: str = parse_pi_mantissa(pi_reference_filename, y)
        e_digits: str = parse_e_mantissa(e_reference_filename, y)

        # Compute digit counts.
        pi_counts: Dict[int, int] = digit_counts(pi_digits)
        e_counts: Dict[int, int] = digit_counts(e_digits)

        # Compute chi-square statistics.
        pi_chi_sq: float = chi_square_statistic(pi_counts, n=y, k=K_DIGITS)
        e_chi_sq: float = chi_square_statistic(e_counts, n=y, k=K_DIGITS)

        # Compute p-values (right-tail).
        pi_p: float = chi_square_p_value(pi_chi_sq, df=DF_DIGITS)
        e_p: float = chi_square_p_value(e_chi_sq, df=DF_DIGITS)

        # Decisions (True means reject H0).
        pi_reject: bool = chi_square_decision(pi_p, alpha=alpha)
        e_reject: bool = chi_square_decision(e_p, alpha=alpha)

        results.append(
            ChiSquareRow(
                num_digits=y,
                pi_p_value=pi_p,
                e_p_value=e_p,
                pi_reject=pi_reject,
                e_reject=e_reject,
            )
        )

    return results

def format_results_table(rows: Sequence[ChiSquareRow]) -> str:
    """
    Format chi-square experiment results as an ASCII table string.

    Parameters
    ----------
    rows : Sequence[ChiSquareRow]
        Result rows as returned by run_chi_square_experiments().

    Returns
    -------
    str
        A multi-line string containing a formatted table.

    Notes
    -----
    - This function is purely for display.
    - Unit tests should validate the structured row data directly, not this formatting.
    """
    header: str = (
        "Num Digits | PI P-VAL     | E P-VAL     | Chi^2 PI Reject | Chi^2 E Reject\n"
        "--------------------------------------------------------------------------------"
    )
    lines: List[str] = [header]


    for r in rows:
        lines.append(
            f"{r.num_digits:9d} | "
            f"{r.pi_p_value:12.6g} | "
            f"{r.e_p_value:12.6g} | "
            f"{r.pi_reject!s:14} | "
            f"{r.e_reject!s:14}"
        )

    return "\n".join(lines)


def main() -> None:
    """
    Command-line entry point.

    This explicitly prints the formatted results table so that students
    can visually inspect scaling behavior of p-values and decisions.
    """
    import argparse

    parser = argparse.ArgumentParser(
        description=(
            "Run chi-square goodness-of-fit tests on mantissa digits of pi and e "
            "across a schedule of prefix lengths Y."
        )
    )
    parser.add_argument("pi_file", type=str, help="Path to pi reference digits file")
    parser.add_argument("e_file", type=str, help="Path to e reference digits file")
    parser.add_argument(
        "--alpha",
        type=float,
        default=DEFAULT_ALPHA,
        help=f"Significance level alpha (default {DEFAULT_ALPHA})",
    )

    args = parser.parse_args()

    ys: List[int] = hw6_y_values()
    rows: List[ChiSquareRow] = run_chi_square_experiments(
        pi_reference_filename=args.pi_file,
        e_reference_filename=args.e_file,
        y_values=ys,
        alpha=args.alpha,
    )

    table: str = format_results_table(rows)

    print("\n===== Chi-Square Goodness-of-Fit Results =====\n")
    print(table)
    print("\n==============================================\n")


if __name__ == "__main__":
    main()
