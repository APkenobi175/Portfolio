# CS3430 - Class 6 - 1/26/26 Notes

## Announcements

- Assignment 1 is graded and returned.
- If you have multiple files, zip them into one file before submitting.
- You don't need to submit the unit tests file.
- Assignment 3 Due on saturday.
- Don't submit the images for assignment 3.

## LU Decomposition

- L stands for lower triangular matrix.
- U stands for upper triangular matrix.

- Say you have a linear system $Ax = b$
  - You can decompose $A$ into $LU$. 
  - Instead of solving the system $Ax = b$, you can solve $LUx = b$
  - You can break this into two systems:
    - $Ly = b$
      - Solve for $y$
    - $Ux = y$
      - Solve for $x$
  - $AX = b$ is equivalent to $LUx = b$, which is the same as solving $Ly = b$.
  - Why is this faster and why is it worth doing?

### Definitions

- **Lower Triangular Matrix**:
  - A matrix where all entries above the main diagonal are zero.
  - Example:
    $$
    L = \begin{bmatrix}
    1 & 0 & 0 \\
    2 & 1 & 0 \\
    3 & 4 & 1
    \end{bmatrix}
    $$

- **Upper Triangular Matrix**:
  - A matrix where all entries below the main diagonal are zero. (Opposite of lower triangular matrix)
  - Example:
    $$
    U = \begin{bmatrix}
    1 & 2 & 3 \\
    0 & 1 & 4 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

### Solving Triangular Systems

- When soliving lower triangular systems, you can use forward substitution.
- When solving upper triangular systems, you can use backward substitution.

### Back Substitution Formula

- $x_i = \frac{1}{a_{ii}} \left( b_i - \sum_{j=i+1}^{n} a_{ij} x_j \right)$
  - This formula allows you to solve for $x_i$ in an upper triangular system.
- Generic Example:

    $$\begin{bmatrix}
    a_{11} & a_{12} & a_{13} \\
    0      & a_{22} & a_{23} \\
    0      & 0      & a_{33} \\
    \end{bmatrix}
    {*}
    \begin{bmatrix}
    x_1 \\
    x_2 \\
    x_3 \\
    \end{bmatrix}
    {=}
    \begin{bmatrix}
    b_1 \\
    b_2 \\
    b_3 \\
    \end{bmatrix}$$
  - From the last row, you can solve for $x_3$ first, then substitute back to find $x_2$ and $x_1$.
  - $x_3 = \frac{b_3}{a_{33}}$
  - $x_2 = \frac{1}{a_{22}} (b_2 - a_{23} x_3)$
  - $x_1 = \frac{1}{a_{11}} (b_1 - a_{12} x_2 - a_{13} x_3)$

  - That is how back substitution works for upper triangular systems.

### Forward Substitution Formula

- $y_i = \frac{1}{a_{ii}} \left( b_i - \sum_{j=1}^{i-1} a_{ij} y_j \right)$
  - This formula allows you to solve for $y_i$ in a lower triangular system.
- Generic Example:
    $$\begin{bmatrix}
    a_{11} & 0      & 0      \\
    a_{21} & a_{22} & 0      \\
    a_{31} & a_{32} & a_{33} \\
    \end{bmatrix}
    {*}
    \begin{bmatrix}
    y_1 \\
    y_2 \\
    y_3 \\
    \end{bmatrix}
    {=}
    \begin{bmatrix}
    b_1 \\
    b_2 \\
    b_3 \\
    \end{bmatrix}$$
  - From the first row, you can solve for $y_1$ first, then substitute forward to find $y_2$ and $y_3$.

  - $y_1 = \frac{b_1}{a_{11}}$
  - $y_2 = \frac{1}{a_{22}} (b_2 - a_{21} y_1)$
  - $y_3 = \frac{1}{a_{33}} (b_3 - a_{31} y_1 - a_{32} y_2)$

  - That is how forward substitution works for lower triangular systems.

- Tip: Always compute the determinant because if its 0, the matrix is not invertible and you can't do LU decomposition.

- LU Decomposition is useful for some matrices, and allows us to solve systems of equations faster and more efficiently.

### Linear Algebra Review

- A = PLU
- This is a permutation matrix.
- A = LU, this only works if L can be composed with U without any row swaps, those row swaps are represented by P.
- Example:
    $$
    P = \begin{bmatrix}
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

  - This is called the identity matrix, which means no row swaps are needed.
  - How do you get this in numpy?

  ```python
    import numpy as np
    I = np.eye(3)  # Creates a 3x3 identity matrix
  ```

- To show a row swap where we swap $R1$ and $R2$:

    $$
    P = \begin{bmatrix}
    0 & 1 & 0 \\
    1 & 0 & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

### Example

$$
    A = \begin{bmatrix}
    2  &  1 & 1 \\
    4  & -6 & 0 \\
    -2 &  7 & 2 \\
    \end{bmatrix}
$$

$$
    L = \begin{bmatrix}
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \end{bmatrix}
$$

- L is defined in python as `L = np.eye(3)`

- First let's perform row operations to convert A into an upper triangular matrix U.

1. $R_{2} = R_2 - 2R_1$
2. $R_{3} = R_3 + R_1$

    $$
        U = \begin{bmatrix}
        2  &  1 & 1 \\
        0  & -8 & -2 \\
        0  &  8 & 3 \\
        \end{bmatrix}
    $$

3. $R_{3} = R_3 + R_2$

    $$
        U = \begin{bmatrix}
        2  &  1 & 1 \\
        0  & -8 & -2 \\
        0  &  0 & 1 \\
        \end{bmatrix}
    $$

- Now we need to update L to reflect the row operations we performed on A.

1. For $R_{2} = R_2 - 2R_1$, we set $L_{21} = 2$.
2. For $R_{3} = R_3 + R_1$, we set $L_{31} = -1$.
3. For $R_{3} = R_3 + R_2$, we set $L_{32} = -1$.
    $$
        L = \begin{bmatrix}
        1 & 0 & 0 \\
        2 & 1 & 0 \\
        -1 & -1 & 1 \\
        \end{bmatrix}
    $$

>[!NOTE] You cannot do this if the determinant is 0, because the matrix is not invertible.

### Another Example

$$
    A = \begin{bmatrix}
    0 & 2 & 1 \\
    1 & -2 & 0 \\
    3 & 1 & 4 \\
    \end{bmatrix}
$$

- We cannot do this because 0 is a pivot, so we need to do a row swap first.

- We will do this row operation:
  - $R_{1} \leftrightarrow R_{2}$
  - After the swap P will be:

    $$
        P = \begin{bmatrix}
        0 & 1 & 0 \\
        1 & 0 & 0 \\
        0 & 0 & 1 \\
        \end{bmatrix}
    $$
  - Remember P just records the swaps
  - Now what will A look like after the swap?

    $$
        A' = \begin{bmatrix}
        1 & -2 & 0 \\
        0 & 2 & 1 \\
        3 & 1 & 4 \\
        \end{bmatrix}
    $$

  - $A' = PA$ Think of $P$ as a swap library that just records every row swap.

- Next Row Operations:

  1. $R_{3} - 3R_1$ => $R_{3}$
  2. $R_{3} - 7/2R_2$ => $R_{3}$
  
    $$
        U = \begin{bmatrix}
        1 & -2 & 0 \\
        0 & 2 & 1 \\
        0 & 0 & \frac{1}{2} \\
        \end{bmatrix}
    $$

    $$
        L = \begin{bmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0 \\
        3 & \frac{7}{2} & 1 \\
        \end{bmatrix}
    $$

### DOING THIS IN PYTHON

1. First you have to pip install scipy

    - `pip install scipy`

```python
import scipy.linalg
from scipy.linalg import lu # LU decomposition function
import numpy as np

# Same matrix as above
A = np.array([[0.0, 2.0, 1.0],
              [1.0, -2.0, 0.0],
              [3.0, 1.0, 4.0]])

P, L, U = lu(A)
```

- Thats literally it

- Now P, L, and U contain the matrices we calculated above.

```python
import numpy as np
import scipy.linalg
from scipy.linalg import lu

np.isclose(np.linalg.norm(A - P @ L @ U), 0.0, atol=1e-12) # This checks if the decomposition is correct
# Returns True
```

- DOing this will tell you if there was row swaps needed or not.
- If there was row swaps, $A = PLU$, if not $A = LU$.

- Sometimes if you can solve a matrix by hands without row swaps, numpy might still do row swaps for numerical stability.
- This is where mathematics differs from science.

### Real World Applications

- Even if you have all the memory in the world decomposing a matrix can makes things faster and more efficient.
- IF you were a data analyst and you had to solve the same system of equations multiple times with different b values, you can decompose A once and reuse L and U to solve for different b values quickly.
- This is WAY faster than inverting the matrix A each time.

- Let's say hypothetically you have a raspberry pi with only 4 GB of ram. You can compute the composition and actually load L and U into the disk, and then load them as needed to solve systems of equations without needing to load the entire A matrix into memory.
- This is how large scale simulations are done in the real world.
