# CS3430 - Class 9 - 2/4/26 Notes

## Announcements

- Homework 4 you are supposed to fail one unit test.
- PRoblem 5 is a image processing problem.
  - Lets say you have a linear system Ax = b.
  - x is the original ("sharp") image row.
  - A is a blurring matrix.
  - b is the blurred image row.
  - ONce you have defined a blurred matrix, 

### Review from Last Class

- Last class we talked about transcedental numbers and what they are.
- We also talked about computing e and π to arbitrary precision.
- We also discussed the history of math

### Machin, Ramanujan, and Chudnovsky formulas for π

- Machin, Leibnitz, Ramanujan, and Chudnovsky are $\pi$ approximations

#### Machin's Formula

- English Astronomer John Machin (1680 - 1751)
- Discovered a formula for π in 1706.
- Formula:
  - $\frac{\pi}{4} \approx 4\arctan(\frac{1}{5}) - \arctan(\frac{1}{239})$
  - its still a mystery how he came up with these numbers, but he did.
  - SOme people think he guessed and checked, over and over again.
  - $x << 1$ 
  - $sum_{k=0}^{\infty} \frac{(-1)^k}{2k + 1} x^{2k + 1}$
- Big leap forward in computing π.
- Converges must faster because subsequent terms get small quickly, they are vanishing exponentially fast.
- How many terms to get P digits of π?
  - About 10-20 terms per arctan. based on machine epsilon.


#### Leibnitz Formula

- Considered one of the co inventors of calculus.
- In this guy's opinion he is THE inventor of calculus.
- Pioneer with infinite series.

- Formula:
  - $\arctan(y) = x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + ...$
  - if X = 1 then,
    - $\arctan(1) = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + ... = \frac{\pi}{4}$
    - So, $\pi = 4(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + ...)$
    - so, $\sum_{k=0}^{\infty} \frac{(-1)^k}{2k + 1} = \frac{\pi}{4}$
  - $\left|\frac{1}{2k + 1}\right| \approx \frac{1}{2k}$

- Convergences very slowly.
- Stable, simple. But, it takes $10^P$ terms to get P digits of π.
- Not efficient.

#### Ramanujan's Formula

- $\frac{1}{\pi} = \frac{2\sqrt{2}}{9801} \sum_{k=0}^{\infty} \frac{(4k)!(1103 + 26390k)}{(k!)^4 396^{4k}}$

- Efficient, but not as efficient as Chudnovsky.
- Discovered by Indian mathematician Srinivasa Ramanujan (1887 - 1920).
- Largely self taught.
- Discovered many deep results in number theory.
- His formulas for π were discovered around 1910.
- Each term adds about 8 digits of π.

#### Chudnovsky's Formula

- Highly efficient
- Invented in 1987 by the Chudnovsky brothers.
  - David and Gregory Chudnovsky.
  - US Mathematicians and computer scientists.
  - David worked for IBM.
  - Greg is still alive and a professor at NYU.
- Converges very quickly.
- Each term adds about 14 digits of π.
- Used in many world record calculations of π.
- How did they come up with this formula?
  - They used modular forms from number theory.
  - Very deep math.
  - Not at all obvious.
  - they def guessed and checked a lot too. lol

- $\frac{1}{\pi} = \frac{1}{426880\sqrt{10005}} \sum_{k=0}^{\infty} \frac{(6k)!(13591409 + 545140134k)}{(3k)!(k!)^3 640320^{3k + 3/2}}$

- This one is the chudnovsky formula actually used in practice.

- How many terms are enough?
  - Never have enough.

- Pi is not reapeating or terminating.
- So we can always compute more digits.
- The digits of the mantissa can be used to generate random numbers.
- The distrubution is truly random.
- So we can use the digits of π as a source of randomness.

### Mpmath vs decimal

| mpmath | decimal |
|--------|---------|
| Computes in binary | Computes in decimal |
| storage in base 2 | storage in base 10 |
| Outputs in decimal | Outputs in decimal |

- If you are doing heavy math that conversion can lead to some rounding errors.
- In wall clock time decimal is slower. binary is faster.
- mpmath is faster for large computations.
- For small computations decimal is faster.

#### Mpmath Example

```python
from mpmath import mp

mp.dps = 50  # set decimal places for float numbers
x = mp.pi # representation of pi up to 50 decimal places
sign = mp.sign(x)
mantissa, exponent = mp.frexp(abs(x))
x = sign * mantissa * 2**exponent

# This will be a decimal number with 50 decimal places
print(x)
```

- `mp.sign` will output -1, 0, or 1 depending on the input. its the sign.

#### Implementing Machin's Formula

```python

from mpmath import mp

def machin_pi_mp(n_terms, dps):
  mp.dps = dps  # set decimal places for float numbers
  one = mp.mpf("1") # pass all of the numbers as strings to the constructor
  # This is to avoid rounding errors, if we use a string it will be represented exactly.

  a = arctan_series_mp(one / mp.mpf("5"), n_terms)
  # approximate the arctan series for n terms for 1/5
  b = arctan_series_mp(one / mp.mpf("239"), n_terms)
  # approximate the arctan series for n terms for 1/239
  
  # Machin's formula returns pi
  return mp.mpf("4") * (mp.mpf("4") * a - b)
```


#### Arctan Series Implementation

```python
from mpmath import mp

def arctan_series_mp(x, n_terms):
  s = mp.mpf("0")

  if x >=1:
    raise ValueError("x must be less than 1 for arctan series")
  x_power = x # term that holds X^(2k + 1)
  sign = mp.mpf("1") # term that holds (-1)^k

  for k in range(n_terms):
    s += sign * x_power / mp.mpf(2 * k + 1)
    x_power *= x * x # update x^(2k + 1) to x^(2(k + 1) + 1)
    sign = -sign # update (-1)^k to (-1)^(k + 1)

  return s
```

- This is how you would implement the arctan series using mpmath.
- Note that we use `mp.mpf` to create mpmath floating point numbers.

#### Testing these Functions

```python
main():
  N = 50  # number of terms in the series
  g = 10
  pi_ref = mp.pi  # reference value of pi
  mp.dps = N + g  # set decimal places for float numbers

  for n in [1, 2, 5, 10, 20, 50, 100]:
    approx = machin_pi_mp(n, dps=mp.dps)
    error = mp.abs(approx - pi_ref)
    print(f"Error: {error} with {n} terms")