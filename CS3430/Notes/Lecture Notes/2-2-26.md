# CS3430 - Class 8 - 2/2/26 Notes

## Announcements

- Homework 4 due on sunday at 11:59pm. (Already done)

### Review

- Last class we talked about number theory and transcendental numbers.

### Continued Fracs. Transcendental Mediation

#### Transcendental Numbers

- A transcendental number is a number that is not a root of any non-zero polynomial equation with rational coefficients.
- Examples of transcendental numbers include $\pi$ and $e$.
- Not the same as imaginary numbers.
- Transcedental numbers are REAL numbers, they just aren't algebraic.

- Complex numbers are numbers that can be expressed in the form a + bi, where a and b are real numbers, and i is the imaginary unit, which satisfies the equation $i^2 = -1$
- Example $\pi + i$ is a complex number, but $\pi$ is a transcendental number.

- Transcendental != Irrational either.
- An irrational number can still go into a polynomial equation with rational coefficients.
- Example: $\sqrt{2}$ is irrational, but it is a root of the polynomial equation $x^2 - 2 = 0$, which has rational coefficients.

- Rational numbers cannot be transcendental, because they are roots of linear polynomials with rational coefficients.
- Example: $x - \frac{3}{4} = 0$ has the rational root $\frac{3}{4}$

- $m = \frac{p}{q} \Rightarrow qx - p = 0$

##### History Lesson

- $e$ was proven to be irrational by Fourier
- in 1873 $e$ is proven to be transcendental by Charles Hermite
- $\pi$ was proven to be transcendental by Ferdinand von Lindemann in 1882
- in 1883 he computed the first 700 digits of $\pi$ manually. It took him long time
- in 1944, the first 100,000 digits of $\pi$ were computed by a team of researchers led by John von Neumann.
- in 1897 louisiana put a bill that required all calculations of pi to be verified by at least 2 people.

#### More about pi

- $\pi \approx 3.14159265358979...$
- $\pi$ Day is March 14th (3/14) because the first 3 digits of pi are 3.14
- at 1:59pm on pi day, you can celebrate pi to 5 digits (3.14159)
- in 2015 at 9:26:53am on pi day, you can celebrate pi to 10 digits (3.141592653)
- in 2026 at 5:35:89am on pi day, you can celebrate pi to 15 digits (3.141592653589793)
- in 2035 at 8:97:93am on pi day, you can celebrate pi to 20 digits (3.14159265358979323846)
- in 2041 at 4:16:92am on pi day, you can celebrate pi to 25 digits (3.141592653589793238462643383279)
- in 2065 at 3:58:97am on pi day, you can celebrate pi to 30 digits (3.14159265358979323846264338327950288419716939937510)
- in 2115 at 9:26:53am on pi day, you can celebrate pi to 40 digits (3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941)
- in 2135 at 3:58:97am on pi day, you can celebrate pi to 50 digits (3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941)
- in 2145 at 9:26:53am on pi day, you can celebrate pi to 60 digits (3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941)

#### More about $e$

- $e = lim_{n \to \infty} (1 + \frac{1}{n})^n$
- $e = \sum_{n=0}^{\infty} \frac{1}{n!} $
- $e \approx 2.7182818284$

- we can celebrate this on 2/7 at 1:82:18am to celebrate $e$ to 10 digits (2.7182818284)

$x = \frac{\frac{N_1}{D_1 + N_2}}{D_2 + N_3} ...$

- You can continue, it depends on how many iterations you want to do.
- Start with the inner most term, that will be your first computation.
- Then you work your way outwards.

- That allows you to be iterative, and more efficient.
- We will use something called generators to do this in python.
- This is better than recursion because we can do it with infinite terms.

- Sticking to mathemtatics is cheap on paper but expensive on silicon.

#### Fractions for $\pi$ and $e$

- $\pi \approx 3 + \frac{\frac{1^2}{6 + 3^2}}{6 + \frac{5^2}{6 + \frac{7^2}{6 + ...}}}$

- This is a very elegant fraction that converges to pi.
- It is called a continued fraction.
- This is great because converging to pi mean's we'll never overshoot it, but the more iterations we do, the closer we get.

- $e \approx 2 + \frac{1}{1 + \frac{1}{2 + \frac{1}{1 + \frac{1}{1 + \frac{1}{4 + ...}}}}}$

- This is also a continued fraction, and it converges to $e$.

#### Generators in Python

- Good for any time you are approximating something infinite with finite numbers.

- yeild keyword allows you to create a generator function.

```python
def gin_nn():
    n = 0
    while 1 = 1:
        yield n
        n += 1
```

- This function is a generator, and an infinite loop.
- It will yeild 1 number at a time, starting from 0 and going up.
- yeild is like return, but the function continues where it left off next time it is called.

```python
nn1 = gin_nn()
next(nn1) # 0
next(nn1) # 1
next(nn1) # 2
next(nn1) # 3
next(nn1) # 4
next(nn1) # 5
```

- Can you do list comprehensions with generators?
- Absolutely.

```python

[next(nn1) for _ in range (5)] # [6, 7, 8, 9, 10]
```

- IF you define a new generator,

```python
nn2 = gin_nn()
[next(nn2) for _ in range (5)] # [0, 1, 2, 3, 4]
```

- Its an entirely different generator, starting from 0 again.

- Vanilla python generators are not re-entrant.

- Python also has a built in module called itertools that has many useful generator functions.

```python
from intertools import islice
nn3 = gin_nn()
list(islice(nn3, 5)) 
# I Slice will run this generation 5 times and list will convert it to a list
# [0, 1, 2, 3, 4]
```

- This is similar to list comprehension, but sometimes more efficient.

- You can generate literally 5+ pages at a time if you want.

```python
list(islice(nn3, 100)) 
# [5, 6, 7, ..., 104]
```

- Fibonacci using a generator

```python
from itertools import islice
def fibo():
    a, b = 0, 1
    while 1 == 1:
        yield a
        a, b = b, a + b # fibonacci update

fib_gen = fibo()
list(islice(fib_gen, 10)) # first 10 fib numbers
```

#### Fractions library in Python

- Python has a built in fractions library that allows you to work with rational numbers exactly.

- Any time you are working with rational arithmetic in python, you should use this library.

from small f import big F

```python
from fractions import Fraction

fraction(a,b) # creates a fraction a/b
fraction(r) # creates a fraction from a float r
# python will attempt to convert the float to a fraction exactly thats a closest approximation
fraction(0.2) # -> fraction(some huge integer, some huge integer), but its close to 1/5

```

- They keep increasing the numerator and denominator to keep the fraction exact, as long as some error level is not exceeded.

- Fortunately 

```python
import math
float(Fraction(math.pi))
```

this converts the fraction back to a float.

#### Continued Fractions in Python using Generators

```python
def cf(N_gen, D_gen):
    Ns = [] # Numerators
    Ds = [] # Denominators

    while 1 == 1:
        Ns.append(next(N_gen)) # get next numerator, have the generator yield the next numerator, append it to the list
        Ds.append(next(D_gen)) # get next denominator, have the generator yield the next denominator, append it to the list
        yield eval_cf(Ns, Ds) # this will take however many numerators and denominators we have so far and evaluate the continued fraction TO BE IMPLEMENTED

def eval_cf(Ns, Ds):
    # We will be going in reverse order, turn the fraction inside out
    # Not like recursion, but kinda opposite of recursion
    assert len(Ns) == len(Ds) # assert means make sure this is true. Is this in python 2? Yes wow, I should remember that and use it at work

    x = Fraction(Ns[-1], Ds[-1]) # negative indexing means count from the end, so -1 is last element
    for N, D in zip(reversed(Ns[:-1]), reversed(Ds[:-1])): 
        # zip takes 2 lists and pairs them up element wise
        # reversed reverses the list
        # Ns[:-1] means all elements except the last one
        x = Fraction(N, D + x) # build the fraction from the inside out
    return x

    # zip returns a list of tuples, where each tuple contains one element from each of the input lists.

def ones(): # this is for the e continued fraction
    while 1 == 1:
        yield 1
    # Thats easy bro

def D_e():
    k = 1 
    while 1 = 1:
        yield 1 
        yield 2 * k
        yield 1
        k = k + 1

cf_e_gen = cf(ones(), D_e())
```

- This is a complete implementation of continue fractions in python using generators and the fractions library.

- Using the fraction library ensures that it keeps everything in fraction form and does not convert to float until the very end, this makes it more accurate.

- Is it normal to link generators like this?
- Yes, its a common pattern.
- Professor Kuyiski HATES SQL and discovered that generators are a great way to do data processing pipelines in python.
- It can process terabytes of data at a time because it does not load everything into memory at once.
- Python 3 improves on this even more with async generators. and functions like next() can be used to retrieve values from these generators without blocking the entire program. python 2 does not have this feature.

- Why use a list of tuples instead of a list of lists?
- Tuples are immutable, meaning they cannot be changed after they are created. This makes them more memory efficient and faster to access than lists, which are mutable.
- Tuples can be used as keys in dictionaries, while lists cannot. This is because keys in dictionaries must be immutable.
- Tuples can be unpacked into multiple variables, making them useful for returning multiple values from a function

- Dicts, tuples, vectors, lists, sets, all have their own use cases.

- In C++ a python list is like a vector, and a python tuple is like a struct.