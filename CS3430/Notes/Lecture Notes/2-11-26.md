# CS3430 - Class 11 - 2/11/26 Notes

## Announcements

- More randomness

- Homework due sunday

### Randomness

- Monobit, Runs, Block Sequence Tests
  - Bunch of graphs and charts

- P value is the probability of getting a test statistic as extreme as the one we got, assuming that the null hypothesis is true.

- The P value is, when we do an experiment and we get a statistic, we convert it to a normal distribution and get a value of Z. the probability of our value being as extreme as Z is the P value. TThe smaller the p value, the more evidence we have against the null hypothesis.

- RNG distribution should not be normal, it should be uniform. If it is normal, then it is not random.

#### Monobit Test Theory

- Monobit is canonical to a whole bunch of other tests. It is the most basic test for randomness

- We have a bit sequence, 011010101...., this sequence is n. We want to find Sn.
- Sn is sum of the bits
- $E[Sn] = \frac{n}{2}$
- $Var[Sn] = \frac{n}{4}$
- $Z_n = \frac{S_n - E[S_n]}{\sqrt{Var[S_n]}}$

- The bit sequence is the data recorded from the experiment, and we want to know if its random or not
- $Sn$ is some random varibale $R$
- From every sequence we can compute a small $r$, which is the value of $R$ for that sequence, the sum of the sequence.

- $S_n - r$
  - Distribution of r? we don't know, but we can attempt to convert it to a normal distribution
- $Var(R) = Z_n = \frac{R - E[R]}{\sqrt{Var[R]}}$
- How do we compute our small $z$ statistic?
  - $z = \frac{r - E[R]}{\sqrt{Var[R]}}$


#### Example

- Bit sequence: `0101100101`
- $\alpha = 0.05$
- $S_{10} = s_{10} = 5$
  - $r = 5$
- $Z_{10} = z_{10} = \frac{5 - 5}{\sqrt{2.5}} = 0$
- P-value of 0 is 1, which is much higher than $\alpha$ so we fail to reject the null hypothesis, which means we don't have enough evidence to say that the sequence is not random. This does not mean that the sequence is random, it just means that we don't have enough evidence to say that it is not random.

- bit sequence 2: `1111111111`
- $S_{10} = s_{10} = 10$
- $Z_{10} = z_{10} = \frac{10 - 5}{\sqrt{2.5}} = \frac{5}{\sqrt{2.5}} \approx 3.16$
- Our P-value is then $0.0016$, which is much smaller than $\alpha$, so we reject the null hypothesis and say that the sequence is not random. This does not mean that the sequence is not random, it just means that we have enough evidence to say that it is not random.

#### Monobit Test in Python

- This is how you implement the monobit test in python. use scipy to compute the P value

    ```python
    def monobit_decision(p_value: float, alpha: float = 0.05) -> str:
        if p_value < alpha:
            return "Reject H0"
        else:
            return "Fail to reject H0"


    from scipy.stats import norm # norm is a set of functions for working with normal distributions
    import math
    def monobit_test(bits: sequence[int]) -> tuple[float, float]: ## this is not required but this is how you use type hints in python. 

    n = len(bits)
    s = sum(bits) # sum is builtin function that sums up a sequence of numbers
    expected_s = n/2
    variance_s = n/4
    z = (s - expected_s) / (math.sqrt(variance_s))
    p_value = 2 * norm.sf(abs(z)) # sf is the survival function, which is 1 - cdf, and cdf is the cumulative distribution function. We multiply by 2 because we want the probability of getting a value as extreme as z in either direction (positive or negative).

    return z, p_value
    ```

- If we have text, we can conver it to a gitantic bit sequence by converting each character to its ASCII value and then to binary. Then we can test if the piece of text contains any information. if its random, then its probably not useful to us.

- sequence: A,C,G,T
- Map A and C to 0 and G and T to 1. this matches biology because A and C are pyrimidines and G and T are purines. Then we can test if the DNA sequence is random or not. If its random, then it probably does not contain any information. If its not random, then it probably contains some information.

- Another way we can use this is lets say we have a video thats 25fps. You can split it into a sequence of frames. You have a matrix of pixels between 0 and 255 per frame. You could convert it so if its <=128 then its 0 and if its >128 then its 1. Then you can test if the video is random or not. Distortions are random, so if there are frames that are fail the monobit test, then there is probably some distortion in the video. now lets get rid of these distorted frames.

#### Runs Test

- A run is a maximal sequence of identical bits
  - `0100110101` has 6 runs: run 1:`0`,run 2: `1`, run 3: `00`, run 4: `11`, run 5: `0`, run 6: `1`, run 7: `0`, run 8: `1`
  - Easy to compute, just iterate through the sequence and count the number of times the bit changes.

- The variables for the run test can be defined as follows:
  - $R$ - number of runs
  - $n_0$ - number of 0s
  - $n_1$ - number of 1s
  - $E[R] = \frac{2n_0n_1}{n} + 1$
  - $Var[R] = \frac{2n_0n_1(2n_0n_1 - n)}{n^2(n-1)}$
  - $Z_n = \frac{R - E[R]}{\sqrt{Var[R]}} \rightarrow z_n = \frac{r - E[R]}{\sqrt{Var[R]}} \rightarrow$ P-Value

- This is slightly more complicated than the monobit test, and there are some differences:
  - The monobit test only looks at the number of 1s and 0s, while the runs test looks at the number of runs of 1s and 0s. This means that the runs test can detect patterns in the sequence that the monobit test cannot.

#### Block Sequence Test

- M = len of blocks
- N = number of blocks
- From M and N we get the distribution of the number of expected blocks.


