# CS3430 Class 4 - 1/14/25 Notes

## Announcements

- Homework 1 is due this saturday at 11:59 PM.

## Numpy And Sympy

- Remember the ice cream example from the last class?
- Review your hand written notes on it
- We solved it by hand
- We were trying to solve the limit as theta aproaches 0+ of I(theta)/C(theta)
- Lets model this problem in numpy and sympy

- **SEE HANDWRITTEN NOTES FOR FORMULAS**

### Sympy Examples of Formulas

- These are formulas from the ice cream example

- $B(\theta) = 2asin(\frac{\theta}{2})$

  ```python
    import sympy as sp
    a = sp.symbols('a', positive=True)
    theta = sp.symbols('theta', positive=True, real=True)
    b = 2 * a * sp.sin(theta / 2)
  ```

  - You have to use sympy symbols or it will break
  - DOn't forget to define symbols

- $I(\theta) = 1/2 \pi (\frac{b(\theta)}{2})^2$

  ```python
    I = (sp.pi / 2) *  (b / 2)**2
  ```


- $C(\theta) = \frac{b(\theta)}{4} \sqrt{4a^2 - b(\theta)^2}$

  ```python
    C = (b / 4) * sp.sqrt(4 * a**2 - b**2)
  ```

  - in code you can use the original equation, no simplification needed

- Now find the limit as theta approaches 0 of I(theta)/C(theta)
- **FULL SCRIPT BELOW**

```python
import sympy as sp
 # unsimplified formulas
 b = 2 * a * sp.sin(theta / 2) # b(theta)
 i = (sp.pi / 2) *  (b / 2)**2 # area of circle
 c = (b / 4) * sp.sqrt(4 * a**2 - b**2) # cone surface area
 rat = i/c # ratio I(theta)/C(theta)
 L = sp.limit(rat, theta, 0, dir='+') # limit of rat as theta approaches 0 from the right

 print(f"Limit as theta approaches 0+ of I(theta)/C(theta): {L}") # 0
 ```

- Can we simplify and push sympy to the limit?
- Yes!

```python
simp_b = sp.simplify(b) # This won't do anything because b is already simple
simp_i = sp.simplify(i)
print(simp_i) # This will simplify i, pi*a^2sin^2(theta/2)/2 in sympy notation
simp_c = sp.simplify(c)
print(simp_c)
simp_rat = sp.simplify(rat) # automatically simplifies the ratio thats cool as fuck
print(simp_rat)
sp.simplify(I/C) # also simplifies the ratio, this will work in this case, but now every case. Its not magic

simp_L = sp.limit(simp_rat, theta, 0 dir = '+')

print(f"Simplified limit as theta approaches 0+ of I(theta)/C(theta): {simp_L}") # 0
```

- Sympy is powerful for symbolic math
- Numpy is powerful for numerical math
- Both are useful for different things

### Numpy Examples of Formulas

- Now lets do the same thing in numpy
- In numpy you have to fix a value, you can't just use symbols like you can in sympy
- Also in numpy we can't just use an expression, we have to define functions
- There are numpy signs for sin, cos, sqrt, theta, etc.

```python
import numpy as np
a = 1.0 # fix a value
def cone_area(theta): 
    b = 2*a*np.sin(theta/2)
    return (b/4.0) * np.sqrt(4*a**2 - b**2)

def ice_cream_area(theta): 
    return (np.pi*a*a/2.0) * (np.sin(theta/2)**2)

# Now we need to model the limit and we need to model it when theta is approaching 0 from the right

# In numpy we do this with logspace

thetas = np.logspace(-1,-20, 20) 

# This returns a numpy array of 20 values from 1.e^-01 (0.01) to 1.e^-20 (0.00000000000000000001)
# You can use logspace to find a limit
# Calculate I(theta)/C(theta) for each theta in thetas
for th in thetas:
    C = cone_area(th)
    I = ice_cream_area(th)
    print I/C
    # Now you can see how it changes as you approximate 0 from the right

```

- Sympy is about symbolic math, so you won't have to know the values of variables
- You can use it simplify expressions and take limits symbolically

- Numpy teaches you to teach in terms of arrays, and matrices, in terms of numerical values
- Scientific python is based completely on numpy
- its for your advantage to invest time in learning numpy
- If you go to internships for data science or scientific computing, numpy is a must know you won't be doing math, you'll be doing numerical approximations with numpy
- Next class we will learn how to solve matrices with ONE LINE of code using numpy

### Bridging Sympy And Numpy

- Convert sympy expressions to numpy functions using lambdify

```python

from sympy.utilities import lambdify 
sp.symbol('x')
u1 = (x**2+2*x+3)**2

d1 = u1.diff(x) # symbolic math derivative

f1 = lambdify(x, d1) # Converts to numpy function

# its a function now so you can call it like a function

print(f1(2.0)) # this finds the derivative at x = 2.0

```

- This is useful if you want to do symbolic math and then convert to numerical math
- You can do symbolic math to simplify or take derivatives, then convert to numpy functions for numerical evaluation

