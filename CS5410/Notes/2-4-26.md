# CS5410 - Class 5 - 2/4/26 Notes

## Announcements

- He taught perline noise wrong last time
- Use the references he posted on canvas
- He recorded this lecture its in the media tab on canvas

### Perlin Noise

- Perlin noise is essentially a measure of how much each vector in the corner is pointing towards the point
- You need to know where the vectors are pointing and how far the point is from each corner. This tells you how much noise value to give.

- Two Grids going on
    1. The grid of vectors
    2. subgrid within a grid cell
- The only vectors being considered for calculations in a cell are the 4 corner vectors and thats it

- So, we need to know what major grid cell we are in, and then we need to know how far each corner vector is from the point. We also need to know the degree each vector is pointing at the point.

- The way we do that is by using the vector dot product
  - E.G
  - $<1, 2, 3> \cdot <4, 5, 6> = 1\cdot4 + 2\cdot5 + 3\cdot6 = 32$
  - The dot product is large when the vectors are pointing in the same direction
  - The dot product is small when the vectors are pointing in different directions
  - The dot product is zero when the vectors are perpendicular.
  - If the dot product is negative, the vectors are pointing away from each other.
  - If the dot product is positive, the vectors are pointing towards each other.
- This tells us how much the vectors overlap.

- We don't care about the magnitude of the vectors, only the direction. So we use unit vectors.
- Since we have 4 vectors (our gradient vectors) we take all 4 vectors and dot them with the distance vector from the corner to the point.
- That tells us how much the corner vector is pointing towards the point, weighted by how far away the point is from the corner.
- This gives us 4 values, one for each corner.

- Each cell in the grid is doing this calculation.

- The gradient vectors are a unit vector. You don't need to normalize them.

#### What we need to do now

- We need a way to transition between major grid cells.
  - That is built into the algorithm
- We also need to pick vectors that give us a nice combination of left and rights and ups and downs and in betweens (randomizing) (there are other ways to do this too)

### Perlin Noise Pseudocode Explained

1. We need to create a permutation table, P

    - P is a way we manage our gradient vectors
    - We make P a size of 256
    - Filled with values 0-255 in some random order, NOT random numbers between 0-255
      - This only stores indexes of the gradient vectors
      - create an array 0 -255
      - shuffle it
      - The P values are the indexes of the gradient vectors
      - Then duplicate the array so its size 512
    - The bigger value, the more memory, but the more distance before the noise repeats

2. Take our x0 and y0 and floor it with the input, and figure out what the integer value is
    - for convenience, we also get the integer value + 1 to get the other corner of the square

    ```cs
    // find integer coords of the square
    x0 = floor(x);
    y0 = floor(y);
    x1 = x0 + 1; 
    y1 = y0 + 1;
    ```

3. Now we need to get the decimal part of the input out. We will use this to decide the weight of the noise values.

    ```cs
    // find relative x and y in square
    dx = x - x0; // decimal part of x
    dy = y - y0; // decimal part of y
    ```

4. Now we need to get the permutation values for each corner of the square
    - This is essentially a hash that lets us look up the vector for the correct point as we get further into the grid

    ```cs
    p00 = P[P[x0] + y0];
    p10 = P[P[x1] + y0];
    p01 = P[P[x0] + y1];
    p11 = P[P[x1] + y1];
    ```

    - More explanation on this:

      - Lets say our permutation size is 4.
        - And our P array is [1, 0, 2, 3, 1, 0, 2, 3] (duplicated)
      - For p11 when we're in the cell (0,0) is the same as P[P[1] + 1]
      - Our input for this example, X = 0.5, Y = 0.5
        - So x0 = 0, y0 = 0, x1 = 1, y1 = 1
        - so for x = 0.5 our permutation value is going to be P[P[0] + 0] = P[1] = 0
        - p01 = P[1] = 2
        - p10 = P[0 + 1] = P[1] = 1
        - p11 = P[1 + 1] = P[2] = 0
      - So we get p00 = 0, p10 = 1, p01 = 2, p11 = 0

      - if x = 1.5 and y = 1.5
        - x0 = 1, y0 = 1, x1 = 2, y1 = 2
        - p00 = P[P[1] + 1] = P[0 + 1] = P[1] = 0
        - p10 = P[P[2] + 1] = P[2 + 1] = P[3] = 3
        - p01 = P[P[1] + 2] = P[0 + 2] = P[2] = 2
        - p11 = P[P[2] + 2] = P[2 + 2] = P[0] = 1
      - This shows us that the corners are the same as before, but the vectors are different
    - Guarantees that a cells bottom left corner and the top right corner of the cell to the bottom left are the same vector

5. Now that we have the indexes of the gradient vectors, now we just get the vectors

    ```cs
    gIndex00 = p00 % lengthof(gradientVectors);
    gIndex10 = p10 % lengthof(gradientVectors);
    gIndex01 = p01 % lengthof(gradientVectors);
    gIndex11 = p11 % lengthof(gradientVectors);
    ```

    - Possible 4 vectors to use:
      - (1, 1)
      - (-1, 1)
      - (1, -1)
      - (-1, -1)

6. Now that we have the vectors, we need to compute the dot products to get the noise values for each corner

    - Dot products are taken between the 4 distance vectors and the 4 gradient vectors
    - gradientVectors[gIndexXY] is the gradient vector at corner XY

    ```cs
    // compute the dot products
    d00 = dot(gradientVectors[gIndex00], <dx, dy>);
    d10 = dot(gradientVectors[gIndex10], <dx - 1, dy>);
    d01 = dot(gradientVectors[gIndex01], <dx, dy - 1>);
    d11 = dot(gradientVectors[gIndex11], <dx - 1, dy - 1>);
    ```

    - This gives us our 4 vectors weighted by how far the point is from each corner

7. Now we need to interpolate between these 4 values. And to do that we will use smooth interpolation

    - Smooth interpolation is just a fancy way of saying we want to interpolate in a way that eases in and eases out
    - We do this by using a smoothstep function

    ```cs
    // smooth the dx and dy values
    sx = Mathf.SmoothStep(dx);
    sy = Mathf.SmoothStep(dy);
    ```

    - Thats pretty easy right?

8. Interpolate our bottom left's vectors dot product and our bottom right's dot product using sx.

    - This gives us the bottom interpolation. Basically finding the halfway point between the two bottom corners. That will be the noise value in the X direction along the bottom edge of the square.

    - Then we do X direction and Y direction to get our final noise value.

    ```cs
    // interpolate between the dot products
    ix0 = Lerp(d00, d10, sx); // bottom interpolation
    ix1 = Lerp(d01, d11, sx); // top interpolation
    result = Lerp(ix0, ix1, sy); // final interpolation

    return result; // RETURN THE FINAL NOISE VALUE
    ```

9. And thats it! We have our Perlin noise value for the point (x, y), we just need to call this function for every pixel we want to shade.
    - But wait, Perlin noise alone is not enough for most applications. We need to add octaves to get more detail.
    - This is where Fractal Noise comes in.
    - Fractal Noise is just multiple layers of Perlin noise added together at different frequencies and amplitudes.
    - This gives us more detail and makes the noise look more natural.

    ```cs
    FractalNoise2D(x, y, octaves, persistence, scale){
        total = 0;
        frequency = 1;
        amplitude = 1;
        maxValue = 0; // used for normalizing result to 0.0 - 1.0

        for i from 0 to octaves-1 {
            total += PerlinNoise2D(x * frequency, y * frequency) * amplitude;

            maxValue += amplitude;

            amplitude *= persistence;
            frequency *= 2;
        }

        return total / maxValue; // normalize to 0.0 - 1.0
    }

    ```

    - Frequency controls how often the noise changes
      - The bigger the frequency the wider the changes
      - Fractal does it again but doubles the frequency and adds it together
      - thats why we see the frequency *= 2
    - Amplitude controls how much each octave contributes to the final noise value
      - The bigger the amplitude the more it contributes
      - Persistence controls how quickly the amplitude decreases for each octave
      - The smaller the persistence the quicker the amplitude decreases
        - thats why we see amplitude *= persistence
    - So by adjusting the number of octaves, persistence, and scale we can get different types of noise
    - For every octave we increase the frequency and decrease the amplitude
      - This gives us more detail in the noise
    - Finally we normalize the result to be between 0 and 1 by dividing by maxValue
      - This is important because we want our noise values to be in a specific range for shading
    - We don't want our small features to override our big features

- Now that we have these values we put them into a color value for our pixel shader
- We can use the noise value to determine the color of the pixel
- E.G
  - color = Color(noiseValue, noiseValue, noiseValue)
  - This will give us a grayscale value based on the noise value
- Or we can use the noise value to determine the height of a terrain
- E.G
  - height = noiseValue * maxHeight
  - This will give us a height value based on the noise value
- The possibilities are endless!

- Tiling with Perlin Noise
  - To make the noise tileable, we need to make sure that the noise values at the edges of the texture are the same
  - We can do this by wrapping the input coordinates
  - E.G
    - x = x % textureWidth
    - y = y % textureHeight
  - This will ensure that the noise values at the edges of the texture are the same, making it tileable.

### Wave Function Collapse (WFC)

- Wave Function Collapse is a procedural generation algorithm that generates content based on a set of input patterns

- Simpler to implmement than Perlin noise

- Algorithm is slow, but produces good results

- Binary Constraint Propagation Algorithm

- Developed in 2016 by Maxim Gumin
  - Relatively new algorithm

- Easiest way to visualize this is with roads.

- Pick all the possible road pieces that can be in each cell

- All of the cells are in superposition because we don't know what the value is until we measure it.

- That affects all the possible states of the neighboring cells.

- A road needs to connect to another road.

- We do this until we have collapsed the entire grid, until there are no more cells in superposition.

- If you get a set of cells that can't be collapsed, thats called a contradiction.
  - In this example there is always a solution. It can happen for more complex rulesets.

- If this happens you have to keep track of the state, and you reach a contradiction, you backtrack to the last valid state and try again.

- Our version will not have contradictions.
  - Backtracking is expensive computationally.

#### Pseudocode with Explanation

1. Create a grid where each cell contains all possible tiles (superposition)
2. Define constraint rules, this is where the magic happens.
    - For each tile we need to define what a valid neighbor is in each direction (up, down, left, right)
    - For example if we have 4 pieces and they are all L shapes (BR, BL, TR, TL)
      - BR_R on the right can match with TL, and BL [TL, BL]
      - BR_R on the left can match with TR, and BR [TR, BR]
      - BR_R on the top can match with BR, and TR [BR, TR]
      - BR_R on the bottom can match with BL, and TL [BL, TL]
    - Doing it this way is not ideal.... Here is how we actually implement it:
      - Assign each tile a binary number with 16 bits.
        - E.G
          - BR = 1 = 0000000000000001
          - BL = 2 = 0000000000000010
          - TR = 4 = 0000000000001111
          - TL = 8 = 1111111111111111
          etcetc
      - Now if you wanna define BR right neighbor again you don't need a list to do it because you can use a single integer value to represent all the possible neighbors by using a bitwise OR operation.
      - Bitwise or means you take two binary numbers and compare each bit. If either bit is a 1, the result is 1. If both bits are 0, the result is 0.
      - Bitwise and means you take two binary numbers and compare each bit. If both bits are 1, the result is 1. If either bit is 0, the result is 0.
        - E.G
          - BR_R = BL | TL = 0010 | 1000 = 1010 = 10
      - So now we can represent all the possible neighbors for each tile in each direction with a single integer value, 10!
      - If we want to check if a tile is a valid neighbor, we can use a bitwise AND operation.
        - E.G
          - validNeighbor = BR_R & TL = 1010 & 1000 = 1000
            - if the result is anything other than 0, then TL is a valid neighbor for BR_R
        - We call this a bitmask
          - A bitmask is a way to represent a set of options using bits in an integer.
          - We store way less data
          - We don't have to loop
          - If you have bugs in this it could be just one bit.
          - You have to do this for all 16 tiles if you have 16 tiles.
          - Every single tile will have 4 bitmasks, one for each direction.
          - That is a lot of integer values to declare.
          - literally do something like this
            - BR_R = BL | TL
          - Even writing them out will be helpful to debug
          - 99% of the issues will be in the bitmasks
          - Each bit mask will be 16 bits long for the assignment
          - to declare them use b before the number to make it binary
            - E.G
              - BR_R = 0b0000000000001010

3. Create a list of cells that need to be collapsed (initially all cells)

4. While there are cells to collapse:
    - Find the cell with the minimum entropy (fewest possible tiles)
    - Collapse the cell to a single tile
    - Choose randomly from remaining possibilities weighted by tile weights

    ```cs
    while(cellsToCollapse not empty){
        cell = findCellWithMinEntropy(cellsToCollapse);
        chosenTile = chooseTileWeightedRandomly(cell.possibleTiles);
        cell.collapse(chosenTile);
    ```

#### Tips

- Easiest way to implement a weighted random is to make a list, and each tile is added however many times its weight is.
  - E.G
    - Tile A weight = 3
    - Tile B weight = 1
    - Tile C weight = 2
    - List = [A, A, A, B, C, C]
    - Randomly pick from the list
    EZ PZ

### Binary Space Partitioning and Random Walks

- Uses graphs and trees

