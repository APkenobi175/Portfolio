# CS5410 - Class 4 - 1/28/26 Notes

## Annoucnements

- Assignment 1 is due tonight

### Procedural Generation

- Different types of procedural generation:
  - Cellular Automata
    - dead or alive cells
    - rules for how cells change over time
    - Figure out what parameters work for generating interesting maps
    - Limited to 2 dimensions
      - E.g land vs water
      - Walls in a dungeon
  - Build the camera controls so you can zoom in and out, move around, etc.
  - Parameters:
    - Chunk width
    - Chunk height
    - num steps
    - initial density
    - seed
    - AI would be good at this one, but not the other algorithms we will talk about, they are more complex.
  - Perlin Noise (Minecraft)
    - Parameters:
      - chunk width
      - chunk height
      - use FBM (fractal brownian motion)
      - noise octaves
      - seed
      - deep water
      - shallow water
      - beach threshold
      - grass
      - mountain
    - Fractal brownian motion
      - A second algorithm that you use on top of perlin noise to make it look better
    - More complex than cellular automata

  - Wave Function Collapse
    - Even more complex
    - Used for generating tile based maps
    - Will be implemented much much later after the other two
    - First portion will be implementing the simpler algorithms first

- Extra credit opportunity render the noise using tilemaplayers instead of simple drawings. But, it needs too look good. 10 points extra credit if you do both cellular automata and perlin noise using tilemaplayers.

- Read the hint sections.

- Your world generation should not be tied to how you are displaying it. You should be able to swap out the rendering method without changing the world generation code.
- For example, an array of booleans for cellular automata, or an array of heights for perlin noise.

- Next class we'll use in class time to work on the assignment.

### Godot Things to know

- Break things up into components
  - E.g a player character could have a sprite component, a movement component, a health component, etc.
  - The tanks could have a playertankcontroller, and a enemytankcontroller component, but the base tank would be the exact same.

#### Entity Component System (ECS)

- Entity Component System (ECS)
  - A way of organizing code
  - Entities are game objects
  - Components are data that can be attached to entities
  - Systems are logic that operates on entities with specific components
    - Allows for more flexibility and reusability of code
  - A damage componenet might operate on a health component
  - a collision system might operate on various physics components
  - Entities are made up of componenets
  - Entities are only a single number in true ECS, its ID.
  - Advantages to ECS
    - If you think of your componenents as an array, 
      - for example if you have a health array, entity 1 has health 100, entity 2 has health 50, etc.
    - You can process all entities with health in a single loop, which is more cache friendly
    - Each system is like an array for entities with having a specific id. 
    - in a single frame you can process entity 1's health, and damage, and more in a single loop. It is highly parallelizable.
  - Godot does not use ECS, but we can learn from it and still use some of the principles.
  - For example there would be a seperate system for "Turret location" that both player tanks and enemy tanks would use, the tank would just have an id for which turret it is using.

- Organize your scenes into Components Entities and Levels
  - Components: reusable pieces of functionality
    - E.g Health.gd, Movement.gd, Turret.gd
  - Entities: game objects made up of components
    - E.g PlayerTank.tscn, EnemyTank.tscn
  - Levels: scenes that contain entities and define the game world
    - E.g Level1.tscn, Level2.tscn

#### Tilemaps

- Don't use tilemap, use tile map layers
- Tile map layer needs to have a tile set assigned to it
- You will probably use similar tile sets for mutiple layers
- its good practice to save a tile set into your assets folder, this way you can easily reuse it across different scenes and levels.
- That way you can use the same tile set for multiple tile map layers.
- Drag a image into the tile set and selet yes in the popup. Now you can edit the tiles in the tileset tab at the bottom.

- Editing/Drawing tile maps
  - Texture - filter - nearest for best pixel art look
  - You can create multiple layers and stack them on top of each other
  - You can use the tileset you created earlier for multiple tile map layers
  - You can use different layers for different purposes
    - E.g background layer, foreground layer, collision layer

- Can you rotate individual tiles?
  - yes, there is a rotate tool, it rotates your selected tile before you place it down.

- Can you attatch scripts to a single tile?
  - no, tiles are for basic graphics only. If you need more complex behavior, use an entity instead bitch

#### Viewport size

- Don't worry about the default viewport, ignore it, that will shrink
- Change the viewport size in your project settings to match your target resolution
- YOu can change your default texture filter in project settings to nearest for pixel art games, that makes life easier.


- Your viewport width and height is not the same as your window size.
- What would be a good value to set?
  - What we want the player to see
  - because each tile is only 16 pixels by 16 pixels, we don't want a huge viewport, because then those tiles would be tiny.
  - so for pixel games, something smaller is better.
  - If you are not using pixel art, and are using vector graphics, then you would want a larger viewport.
  - most screens are 16:9 aspect ratio, so something like 1280x720 or 1920x1080 would be good.
  - Maybe you want to handle multiple aspect ratios, then you can use a viewport that is a bit taller, like 1280x800, so that on wider screens you just see more on the sides.
  - So, with pixel art we wanna keep the 16:9 aspect ratio, but we also want to keep the tiles a good size.
  - So something like 320x180, or 640x360 would be good choices

- Lets say our screen is 1000x1000, but our viewport is 800x800, does this scale nicely if we are doing pixel art?
  - No, because 1000/800 = 1.25, so each pixel would be scaled by 1.25, which is not an integer, so it would look blurry.
  - We want to make sure that our window size is a multiple of our viewport size, so that each pixel is scaled by an integer value.
  - So if our viewport is 320x180, we could have a window size of 640x360 (2x), 960x540 (3x), 1280x720 (4x), etc.

- A good rule of thumb is to do something that scales nicely to standard resolutions, like 1280x720, 1920x1080, etc.

- For pixel art there is a viewport size that scales nicely to all of those and its:
  - 640x360

- After changing the viewport, we need to tell it how to stretch to the window size.

#### Stretch Mode

- We want to use canvas_items scale mode. Aspect to keep the aspect ratio.
- With pixel art we want to scale it integer values only.

#### UI

- UI works the same as every other node
- It exists in 2D space
- You can create a scene for your UI

- Put your labels in a canvas layer so that they are always on top of everything else
- Now we don't care about what the camera is seeing, we want to make our ui correct to the context of our viewport.

- YOu don't have to manually position things, which is what I did with my flappy bird game so it looks bad.

- To fix this issue you can use containers. They help you position things and they can be nested. Similar to flex containers in ignition at work.

- This makes it much nicer to position things.

### Changing Scenes (if you wanna change levels)

- You need some way of keeping track of what scene you are on

- The easiest way to do this is to have a global state.

- You can create a scene called GameManager.
- This scene will be applied to every other scene.
- To make it always exist with only one instance, in your project settings theres a tab called global. In the autoload tab hit the open button and find your gameManager and click add.
- Now you have a global scene that is always available in our project, we can access it from anywhere.
- Then we attach a script to it

`getTree().ChangeSceneTo(levels["level1"]);`

- This is how we change scenes

- We create a dictionary of levels that maps levels to their scene paths.

- And then switching scenes is like changing state in web development.

- To demo this create a new scene called home, and main menu

- In the main menu scene change it to be a canvas layer, with a button that says "Start Game"

- in the script for the main menu, in the _ready function, 

```csharp

var startButton = GetNode<Button>("StartButton");

startButton.Pressed += () => {

    GameManager.Instance.ChangeSceneTo(GameManager.Instance.Levels["level1"]);

};
```

- This is how we change scenes when the button is pressed, it gets your game manager instance, and calls the change scene function with the level1 scene path.

- You need to retrieve the game manager instance, its a global object.

- Any kind of global state it should be kept track of in the game manager, like maybe settings, stuff like that consistent across scenes.

### Save things

- Godot has a lot of ways to svae things
- the easy way is to dump it into a json file
- there are builtin ways like using the File class
- Theres a lot of documentation on it

### Animation Sprites

- If you want the run animation to play when the player is running, go back to your sprite frames and rename the animation "run", and you can create a new one called "idle", put those frames in there. Now we have two animation types

- you can set it to auto play, but we don't want to do that we want to control it.
- But, we can make the idle animation auto play, and in our script we can change it to run when the player is moving.

```csharp
if (velocity.Length() > 0) {
    animatedSprite.Play("run");
} else {
    animatedSprite.Play("idle");
}

```

- Beautiful

### Procedural Generation Algorithms

#### Cellular Automata

- This is just Conway's Game of Life but for map generation

- x represents a living cell, blank represents a dead cell

```python
1 2 3 4 5 6 7 8 9 10
1 |   x x     x
2 | x x x x x
3 |   x x x x
4 |     x x x
5 | x x x x x x
6 | x x     x      x
7 |     x x
8 |   x x x x
9 | x x x x x
10| x     x x
```

1. Pick some random cells to be alive
2. Make some rules that determine which cells stay alive, die, or come back to life
    - If you're a living cell and you have more than 2 neighbors or less than 1 neighbor, you die (overpopulation or loneliness)
    - If you're a dead cell and you have exactly 3 neighbors, you come back to life (reproduction)
3. These rules don't work for terrain generation, so we will modify them.

4. Our goal is so that the rules make lonely cells die off, and clumps of cells grow, and fill in small gaps.

5. Our goal is to create rules that do this over multiple iterations.

6. Hint: Its a lot simpler than it sounds like it is, try to just pick a number and go with that.

    - If its dead and it has a lot of neighbors, it comes to life
    - If its alive and it has a lot of neighbors, it stays alive

7. We are looking for organic shapes.
8. Realistically you won't need to do more than 3 or 4 iterations to create something interesting.

9. Remember that the new world is based on the old world, you are not gonna modify the world, you are going to create a new world based on the old world, and replace the old world with the new world at the end of each iteration. Don't modify the world in place, or it will fuck shit up.

10. Interpret live or dead cells however you want, E.G mountains and valleys, walls and floors, water and land. yeah bro.

- Generate your world 1x1 and then scale it up, each cell in your world takes up 2 tiles, then you are guaranteed that if you have something thats a single cell it will actually be 2x2 in the final world.

#### Perlin Noise

- Invented by a guy named Ken Perlin in 1982
- The idea of Perlin noise is:
  - You have a graph, as X increases, I want to create a natural looking curve.
  - Random values is not going to cut it.
  - But we still wanna randomly generate the terrain.
  - When we pick a random value thats close to it, then the random value in the y direction should also be close to the previous value, this way we end up with close randomness and not jerky randomness.
  - If we zoom in we ended up with something with smooth curves, and if you squint you can draw some nice hills and valleys.
- How to do it
  - Think of our world as a grid space.
  - The input is a floating point number, that is represented as an x value.
    - We break it into its integer and decimal portions
    - if X = 1.5
      - integer portion = 1
      - decimal portion = 0.5
    - The integer tells us which grid cell we are in.
    - The decimal portion tells us how far we are into the cell.
    - Every grid point gets a vector assigned to it. 
    - What the vector is is determined by the integer portion of the input.
    - each of the corners gets a vector assigned to it.
    - Then we compute a vector from the corner to the input point.
    - Then we take the dot product of each of those vectors with its coresponding corner vector.
    - That will give us a floating point number somewhere between 0 and 1.
    - Now we want to do some sort of linear interpolation between the dot products of our vectors
    - We want to take the values that we get from dot products and interpolate using lurping. 
    - The linear function gives us a starting point and an end point, and a decimal value between 0 and 1 that tells us how far we are between the two points.
    - Once you compute the dot products, im gonna come up with a function that smooths the decimal portion, so that it eases in and out.
    - The function ken used was called `fade(float t)`
    - ` return {(t * t * t) * (t * (t * 6 - 15) + 10); }`
    - Come up with a function you will interpolate between the two dot products using the smoothed decimal portion.
    


### Tile Maps

- Some tiles don't look nice together, (right click to delete btw)
- You can add a terrain set to the tilemap layer.
  - Mode: Match corners and side
  - Name: ground (example)
- Inside of the tileset now under a paint, you can select a property and select a terrain layer (ground)
- Now you can select the tiles that are in the terrain set, and create a bitmask for them.
- You are basically saying these are the edges, we are going to line up the edges of the tiles with the edges of the tiles they can connect with.
- They are lined up in such a way as long as blue is touching blue, then they are valid neighbors of each other. 
- It will check both sides and the corners.

- So now if you lay a tile down it will decide what the valid tiles for it's neighbors are.

- How is this related to Cellular Automata?
  - After you generate your world with cellular automata, you can use the tilemap layer with terrain sets to render it nicely.
  - Instead of just drawing rectangles for each cell, you can use the tilemap layer to make it look nice. GENIUS, only 2 tiles? or 2 tile types?
  - For water and land you can have a water tile and a land tile, and the terrain set will handle the transitions between them.
  - Can you have multiple water tiles for variety?
    - Yes, you can have multiple tiles for the same terrain type, and it will randomly select one when placing it down, but it will select the correct tile based on the neighbors. so only correct edges can be next to each other.
  - Multiple land tiles as well for variety.
  - This is very cool. for 5pts extra credit under the cellular automata section of the assignment.

- You can also do all this programatically, thers a function where you give it a list of cells, and automatically generate the tilemap for you based on the terrain set. So if you give it the floor cells it will automatically generate the walls and corners and stuff for you. Check the docs for TileMap.setCells() or something like that.
