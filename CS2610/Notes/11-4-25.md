# Side Effects in React

* **Side Effects** are pieces of code that run after a component finishes rendering.
* They allow you to do things like fetch data, start timers, interact with the DOM, or perform animations — anything that happens *after* React updates the screen.

---

## Why Side Effects Exist

* Normally, React components render UI based on state and props.
* But sometimes the *application itself* needs to perform actions outside of rendering.
* Examples:

  * Loading data from an API when a component appears.
  * Setting up timers.
  * Cleaning up resources when a component disappears.
* These are considered **side effects** because they occur *as a side effect of rendering.*

---

## Violating Unidirectional Data Flow (Kind Of)

* In React, data usually flows one way: **User → Event → State → UI**.
* But side effects allow the **application** to also trigger actions.
* Example: A timer changing state after it’s started by a user click.
* This slightly “extends” unidirectional flow — still predictable, just automated.

---

## The `useEffect` Hook

* To run side effects, use the **`useEffect`** hook.
* Import it:

  ```js
  import { useEffect } from "react";
  ```
* Syntax:

  ```js
  useEffect(() => {
      // Code to run after render
  });
  ```
* This function runs **after** React renders and updates the DOM — not during rendering.

---

## Dependency Array – Controlling When It Runs

* `useEffect` takes a second argument: a dependency array.

  ```js
  useEffect(() => {
      console.log("Runs when input changes");
  }, [input]);
  ```
* Rules:

  * No array: runs **after every render.**
  * Empty array `[]`: runs **only once** (on mount).
  * With dependencies `[x, y]`: runs **when x or y changes.**

---

## Example 1: Run Once on Mount

```js
useEffect(() => {
    console.log("Component just rendered!");
}, []);
```

* Runs only once after the first render.
* Useful for:

  * Loading data from an API.
  * Setting up event listeners.
  * Initializing things like maps or charts.

---

## Example 2: Reacting to State Changes

```js
const [toast, setToast] = useState("");

useEffect(() => {
    if (toast !== "") {
        const timer = setTimeout(() => {
            setToast(""); // Clear toast after 4 seconds
        }, 4000);
        return () => clearTimeout(timer); // Cleanup if toast changes early
    }
}, [toast]);
```

* Runs every time `toast` changes.
* Starts a timer when a toast appears, and clears it after 4 seconds.
* If the user clicks multiple times, multiple timers can exist — be careful with cleanup.

---

## Example: Complete Component

```jsx
import { useState, useEffect } from "react";

export function ToastExample() {
    const [toast, setToast] = useState("");

    useEffect(() => {
        if (toast !== "") {
            const timer = setTimeout(() => {
                setToast("");
            }, 4000);
            return () => clearTimeout(timer);
        }
    }, [toast]);

    return (
        <div>
            <button onClick={() => setToast("Wow, that was crazy!")}>
                Show Toast
            </button>
            {toast && <div>{toast}</div>}
        </div>
    );
}
```

---

## Key Takeaways

* **`useEffect`** runs *after* React updates the DOM.
* You can have **multiple `useEffect` hooks** in one component.
* Use the dependency array to control when effects run.
* Common use cases:

  * Fetching data on mount.
  * Responding to state changes.
  * Starting or clearing timers.
  * Cleaning up when a component unmounts.

# Clean-Up Functions in React Effects

* Sometimes a **side effect** changes something outside React that needs to be **undone** when the component is removed — like timers, subscriptions, or event listeners.
* If we don’t clean up, the effect keeps running even after the component is gone, causing **memory leaks**.

---

## The Problem

```jsx
function KeyListener() {
  const [key, setKey] = useState("");

  useEffect(() => {
    window.addEventListener("keydown", e => setKey(e.key));
  }, []);

  return <div>{key}</div>;
}
```

* When this component is **unmounted**, the event listener is **still active**.
* The window continues to listen for key presses even though the component no longer exists.
* Result: **Memory leak** and unexpected behavior.

---

## The Solution — Clean-Up Function

* The function passed to `useEffect` can **return another function**.
* That return function is the **cleanup function** — React runs it when:

  * The component is removed (unmounted), or
  * One of the dependencies changes (before running the effect again).

---

## Fixed Example

```jsx
function KeyListener() {
  const [key, setKey] = useState("");

  useEffect(() => {
    function keyDown(e) {
      setKey(e.key);
    }

    window.addEventListener("keydown", keyDown);

    // Clean-up function
    return () => {
      window.removeEventListener("keydown", keyDown);
    };
  }, []);

  return <div>{key}</div>;
}
```

---

## Key Points

* Declare the listener as a **named function** (`keyDown`) so you can remove the exact same reference later.
* The **cleanup function** runs automatically when:

  * The component unmounts.
  * Dependencies in the array change.
* Prevents **memory leaks** and **duplicate event handlers**.
* Always clean up effects that:

  * Subscribe to events.
  * Start intervals or timers.
  * Open network connections.
