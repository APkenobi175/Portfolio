# Client Side Routing

* When bvuilding React applications you have to think of a page a little differently than traditionally. Lets talk about SPAs and MPAs

## Multi VS Single page applications

### Single Page Applications (SPAs)

1. Architecture
    * Ina  single page application the entire application is contained within a single HTML page. The pagfe is loaded ones and different interactions changes how the page looks by dynamically udpating it using client side scripting,t ypically javascrip
2. Navigation
    * SPAs use client side routing to manage navigation. Whena  user clicks on links or interacts with the application the routing log dynamically swaps out different views or componenets without requireing a full page reload. This provides a smoother and more interactive user experience
3. Page Transitions
    * Since SPAs only update the necessary parts of the page, transitions between different views are usually faster and more seamless compared to MPAs which often involve full page reloads.
4. Performance
    * SPAs can offer better performance for certain interactions because they minimize the amount of data that needs to be transferred between the client and server.
5. Initial load time
    * SPAs might have longer initial loading times because the entire application code needs to be loaded upfront. However, techniques like code splitting can be used to mitigate this
6. SEO Challenges
    * Historically, SPAs faced challenges with search engine optimization (SEO) because search engines had difficulty indexing dynamically loaded content. However, modern solutions like server-side rendering (SSR) and pre-rendering have improved SEO for SPAs.

### Multi-Page Applications (MPAs)
1. Architecture
    * Multi-Page Applications consist of multiple separate HTML pages, each representing a different view or section of the application. Clicking on links or interacting with the application typically results in the browser fetching a new HTML page from the server.
2. Navigation
    * MPAs use traditional server-side routing. When users navigate between different sections, the browser fetches a new HTML page from the server, causing a full page reload.
3. Page Transitions
    * Because MPAs involve full page reloads, transitions between different views can be slower and less seamless compared to SPAs.
4. Performance
    * In MPAs, since entire pages are often reloaded, there can be a higher amount of data transferred between the client and server, potentially affecting performance, especially on slower connections.
5. Initial load time
    * MPAs can have faster initial loading times because the server sends a fully-rendered HTML page, which can be seen by users before additional assets are loaded.
6. SEO Challengesv
    * MPAs historically have an advantage in SEO because search engines can easily crawl and index different pages, as each page has its own URL.



* In conclusion SPAs offer a more dynamic and interactive user experience with smoother transitions, however they face other challaenges like load times and SEO

## Basics of Client Side Routing

* Client side routing is a little different than server side routing
* Rather than using the server like django, we will be using javascript to dynamically change our pages on the client side
* We need a state that tells us what page we are on
```jsx
import { useState } from "react"
import { Page1 } from "./page1"
import { Page2 } from "./page2"
import { Page3 } from "./page3"
function App() {
    const [count, setCount] = useState(0);
    const [page, setPage] = useState("page1") /* Page state */

    let component;
    if (page === "page1"){
        component = <Page1 />

    }else if (page === "page2"){
        component =<Page2 />
    } else if (page === "page3"){
        component = <Page3 />
    } else{
        component = <div>Page not Found </div>
    }

    return(
        <>
            <nav>
            <button onclick = {() => setPage("page1")}>Go to page 1</button>
            <button onclick = {() => setPage("page2")}>Go to page 2</button>
            <button onclick = {() => setPage("page3")}>Go to page 3</button>
            <button onclick = {() => setPage("page4")}>Go to page 4</button>
            <button onClick = {() => setCount(count+1)}>Count: {count}</button>
            {/*TODO : PUT PAGERS ON THE SCREEN*/}
            </nav>
        </>
    )
}

export default App

```
* Thats the gist of it, instead of having seperate pages, our pages are basically just different states
* But we still need to leave intact all the browser functionality we would expect
* To do this we will use react router

### React Router

* We will use the previous example and instead convert it to how we'd do it in react router
* React router is a seperate appication we need to install
* `npm install react-router-dom --save`
* Go back and make sure react-router-dom is in your dependancies
* Put your router in the main.jsx file
* We have to import it 
* DO NOT CREATE THE ROUTER INSIDE OF A COMPONENT
* IT MUST BE CREATED IN THE GLOBAL SCOPE OF A MODULE
* SImilar to URLS.py
* Then you render the routerprovider and provide the router as a prop to the routerprovider
* Then we can integrate our other pages in the HashRouter by making them children 
* Then, after we do that we need to go our app.jsx and render a componenet called the Outlet componenet
* This would allow us to implement links to our other pages via a nav bar
* We can use the Link componenet when we use react router, then it doesn't matter what router we are using. You can only use the link tab for componenets taht arre part of the router (our page componenets.)
```jsx
/*MAIN.JSX*/
import { Page1 } from "./page1"
import { Page2 } from "./page2"
import { Page3 } from "./page3"
import { createHashRouter, RouterProvider } from 'react-router-dom'

const router = createHashRouter{
    {
        path: "/",
        element: <App />,
        children: [
            {
                path: "/",
                element: <Page1 />
            },
            {
                path: "/page2",
                element: <Page2 />
            },
            {
                path: "/page3",
                element: <Page3 />
            },
            
        ]
    },

}

ReactDOM.createRoot(document.getElementById('root')).render(
    <RouterProvider router = {router}>
)
```
```jsx
/*APP.JSX*/
import { Outlet } from "react-router-dom";
import { Link } from "react-router-dom"

function App(){
    return(
        <div>
            <nav>
              <Link to "/">Page 1</Link>
              <Link to "./page2">Page 2</Link>
              <Link to "./page3">Page 3</Link>


            </nav>
        <Outlet /> /* this is our page */
        </div>
    );
}

```

### Path Parameters in Client Side Routing

* In our router, and path, we need to specify the path with it's parameters, and we do that with `:`

```jsx
/*Main.jsx*/
const router = createHashRouter{
    {
        path: "/",
        element: <App />,
        children: [
            {
                path: "/",
                element: <Page1 />
            },
            {
                path: "/page2/:id",
                element: <Page2 />
            },
            {
                path: "/page3/:drugs",
                element: <Page3 />
            },
            
        ]
    },

}
```
* Then you put it into your App's return statement like this
```jsx
/*App.jsx*/
<Link to = {`/user/${user.id}`}>{user.name}</Link>
```
* Now we need to access that from our User.jsx
* The hook we want to use for this is the `{ useParams }` hook
* How do we navigate programatically?
* There is another hook we can use called `{ useNavigate }`
* We pass a number into our useNavigate `navigate(-1)`, we can also put a path in `navigate("/")`
```jsx
/*User.jsx*/
import { useParams } from "react-router-dom"
import { useNavigate } from "react-router-dom"

export function User(){
    // go to the db to get user with id blah
    const params = useParams();
    const navigate = useNavigate();
    console.log(params);
    return(
        <div>
          <button onClick ={() => navigate(-1)} >Back</button>
        <h1>I am the user page</h1>
    )
}
```
--- 

## Routers

### Hash Router

* In a Hash router the client side router looks at everytyhing that comes after the # in a URL to determine which componenent to display. An example would be `http://mywebsite.com/#/page1.`

* Advantages
  * The server ignores the # and everything after that means if a user refreshes the page thent he server will just think we are equesting the / page, meanwhile the browser remembers the # and the clinet side router can still reload the correct page
  * YOur webpage can be hosted at any subpath
* Disadvantages
  * the # has another meaning for the browswer, it will automatically scroll you to the anchor tag that has the URL that matches the hash. If you are using hash routing you can no longer use this feature


### Browser Routing

* With the browser router, the router looks at the normal patht o determine which page to dispaly. Reat router disables the defaulty behavour opf changing the path, which woudl normally make a request to the server. An example would be `http://mywebsite.com/page1`

* Advantages
  * The browswer already has robust tooling that the router can leveragfe to perform and manage navigation. This makes the briwswer router a little bit faster
  * The URL appears more normal
* Disadvantages
  * If the user refreshes the page thent he whole path is sent to teh server, which means that your server needs to be configured to send the client app regardless of the path that was sent