# Unidirectional Dataflow
State -> View -> Actions -> State -> View -> Actions
### Application State

1. State - We have some form of application state, and that state ends up in the UI, we represent this state in the view
2. View - Will be updated to reflect the state
3. Action - an action will change the state

* Everything that changes in the UI needs to be driven by a change in the state
* **EVERYTHING**

* The reason we call this unidirectional is there isn't any jumping between them. You have to go with the flow.

* Uniderectional dataflow is a LAW
* You can however trigger an action by the state changing, they are called side effects and they are a necessary evil

### State in React

* React manages state in a way that if we change the state react will automatically change the UI for it. 
* All we have to do is change the state of our program. 

* All properties in React are camelcase. For a button that calls a function you do it like this

```
<button onClick={decrement}> Decremenet </button>
```

#### Example
* Rather than manually updating the value inside the function, since that breaks the laws of Uniderectional flow, we use something called a HOOK
* It hooks into the react lifecycle. Watching state and updating UI
* That is what the useState hook is
* First parameter is the value of the state, and the second parameter is the functiont to replace old state with new state. What we pass into useState is the default value `const [count, setCount] = useState(0);`
* YOu cant "change" the state, all you do is replace the old state with a new state
* It's re rendering, it sounds inefficnet, but there will be no preformance issues, it does it really quicky

* Appname.jsx
```jsx

import { useState } from "react"


export function Counter(){
	const [count, setCount] = useState(0);
	console.log("counter was called")


	function increment(){
		setCount(count + 1);
	}

	function decrement(){
		setCount(count-1);
	}


	return(
		<div>
			<div>{count}</div>
			<div>
				<button onClick={increment}>Increment</button>
			</div>
			<div>
				<button onClick={decrement}>Decrement</button>
			</div>
	)
}
```

### State Gotchas
* All these gothas relate to the idea of "Re-Rendering"
* React doesn't keep track of the "Count" function because its a const and doesn't change it keeps track of the useState value. 
* So if you call `setCount(count + 1);` multiple times it won't do anything because count is still 0. 
* If you wanted to do that you can use a middleware chain 
```
setCount((oldState)) => {
	return oldState + 1;
}
setCount((oldState)) => {
		return oldState + 1;
		}
}
console.log(count)
```
* COunt is still 0, but it will add 1 twice. 
* Do it this time so you don't have to worry about changing your state multiple times in one function call

### State with Form Elements

* Even our input values should be tied to state. if we type something the state changes and it causes our ui to update\
* The way we use this is with the value tag in the input, `value = {name}`
* You also need to add an onchange listener for this as well `onChange`

* **Example:**
```jsx
import { useState } from "react"

export function NewAccountForm() {
	const [email, setEmail] = useState("")
	const [name, setName] = useState("")
	const [password, setPassword] = useState("")

	return(
		<form>
			<div>
				<label>Name: <input type = "text" value ={name} onChange =  /> </label>
			</div>
			<div>
				<label>Email: <input type = "text" value ={email} /> </label>
			</div
			<div>
				<label>Password: <input type = "text" value ={password} /> </label>
			</div
			<button> Create Account </button>
		</form>


				
	)	

	
}
```
