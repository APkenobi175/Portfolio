# Unidirectional Dataflow
* Flow: State -> View -> Actions -> State -> View -> Actions
### Application State

1. State - We have some form of application state, and that state ends up in the UI, we represent this state in the view
2. View - Will be updated to reflect the state
3. Action - an action will change the state

* Everything that changes in the UI needs to be driven by a change in the state
* **EVERYTHING**

* The reason we call this unidirectional is there isn't any jumping between them. You have to go with the flow.

* Uniderectional dataflow is a LAW
* You can however trigger an action by the state changing, they are called side effects and they are a necessary evil

### State in React

* React manages state in a way that if we change the state react will automatically change the UI for it. 
* All we have to do is change the state of our program. 

* All properties in React are camelcase. For a button that calls a function you do it like this

```jsx
<button onClick={decrement}> Decremenet </button>
```

#### Example
* Rather than manually updating the value inside the function, since that breaks the laws of Uniderectional flow, we use something called a HOOK
* It hooks into the react lifecycle. Watching state and updating UI
* That is what the useState hook is
* First parameter is the value of the state, and the second parameter is the functiont to replace old state with new state. What we pass into useState is the default value `const [count, setCount] = useState(0);`
* YOu cant "change" the state, all you do is replace the old state with a new state
* It's re rendering, it sounds inefficnet, but there will be no preformance issues, it does it really quicky

* Appname.jsx
```jsx

import { useState } from "react"


export function Counter(){
	const [count, setCount] = useState(0);
	console.log("counter was called")


	function increment(){
		setCount(count + 1);
	}

	function decrement(){
		setCount(count-1);
	}


	return(
		<div>
			<div>{count}</div>
			<div>
				<button onClick={increment}>Increment</button>
			</div>
			<div>
				<button onClick={decrement}>Decrement</button>
			</div>
	)
}
```

### State Gotchas
* All these gothas relate to the idea of "Re-Rendering"
* React doesn't keep track of the "Count" function because its a const and doesn't change it keeps track of the useState value. 
* So if you call `setCount(count + 1);` multiple times it won't do anything because count is still 0. 
* If you wanted to do that you can use a middleware chain 
```jsx
setCount((oldState)) => {
	return oldState + 1;
}
setCount((oldState)) => {
		return oldState + 1;
		}
} 

console.log(count)
```
* COunt is still 0, but it will add 1 twice. 
* Do it this time so you don't have to worry about changing your state multiple times in one function call

### State with Form Elements

* Even our input values should be tied to state. if we type something the state changes and it causes our ui to update\
* The way we use this is with the value tag in the input, `value = {name}`
* You also need to add an onchange listener for this as well `onChange`
* Any time you change a field it triggers a change you will basically just use onChange for everything. You can write the functions inline on the onChange = 
* Whenever you do something with forms you should specify a submit handler `function handleSubmit`
* `e.preventDefault()` will prevent the page from refreshing when you press the submit button
* Then you can use a fetch api to do a get or a put
* **Example:**
```jsx
import { useState } from "react"

export function NewAccountForm() {
	const [email, setEmail] = useState("")
	const [name, setName] = useState("")
	const [password, setPassword] = useState("")


	function handleSubmit(e){
		e.preventDefault()
		console.log(name, email, password);
		
	}

	return(
		<form>
			<div>
				<label>Name: <input
				type = "text"
				value ={name}
				onChange =  {() => setName(e.target.value)}
				/>
				</label>
			</div>
			<div>
				<label>Email: <input
				type = "text"
				value ={email}
				onChange =  {() => setEmail(e.target.value)}
				/>
				</label>
			</div>
			<div>
				<label>Password: <input
				type = "text"
				value ={password}
				onChange =  {() => setPassword(e.target.value)}
				/>
				</label>
			</div>
			<button> Create Account </button>
		</form>


				
	)	

	
}
```
* This is how you create a form without violating the laws of unidirectional dataflow

### Using Arrays and Objects as State Values
* Your state can be anything
* You can use arrays, objects, class instances, nested arrays, it can literally be ANYTHING
* The rule is the same, ALL STATE needs to be unchangable 
* You need to copy the current state into a new state, do whateveer you want to your new state, and then replace the old state with the new state please see saveNote() and deleteNote() function for example

* if you copy and change but forget to set state to your new state you will get a bunch of weird memory bugs
* if you copy then you need to change
* if you don't need to change then don't copy

* Example app.jsx
```jsx
import { useState } from 'react'

function App(){
	const [noteContent, setNoteContent] = useState("")
	const [notes, setNotes] = useState([]) // Empty array for the state
	// REMEMBER NOTE CONTENT NEEDS TO BE IMMUTABLE 
	// So instead of modifying, we replace with new state
	function saveNote(){
		const newState = ; // create new state copy of old state
		newState.push(noteContent) // add new note
		setNotes(noteContent) // set state to be your new state
		setNoteContent("") // clears out text box
	}

	function deleteNote(note){
		const newState = [..notes]; // create new state copy of old state
		newState.splice(newState.indexOf(note), 1) // there is no delete function in javascript you gotta splice it
		setNotes(newState); // set state to be your new state

	}
	return(
		<>
		<h1>Notes</h1>
		<div>
			<input
			type = "text"
			value={noteContent}
			onChange={e => setNoteContent(e.target.value)}
			/>
			<button onclick = {saveNote}>Save</button>
		</div>
		<div>
		{
			notes.map((note)=> {
				return (
					<div key={note}>
					{note}
					<button onClick={() => deleteNote(note)}>Delete Me! </button>
					</div>
				)
			})
		}
		</div>
	)
}

export default App
```


### Using Objects as State
* The same rule applies when using objects as states
```jsx
const [user, setUser] = useState({ name: "Joseph", email: "joseph.ditton@usu.edu" })

// later in a user action
const newState =  {...user}; // copy the user into a new object
newState.email = "somenewemail@website.net"
setUser(newState);
```
* This will copy the user state and override the email with a new value

### More Complex States
* Lets say you have a list of users in your state. The question isL are both the list and the users int he list supposed to be immutable? You actually havbe some flexibility there. At the very least the list should be immutable - whatever the outermost object.array is must be immutable. For example, you can just do this:

```jsx
const [users, setUsesr] = useState([{ name: "Joseph", email: "joseph.ditton@usu.edu" }, ...])
// ... is not valid sytax here, it just means you might have more that one user

// later in a user action
const newState = [...users];
newState[2].email = "somenewemail@website.net"
setUser(newState);
```
* There are cases where you need to make the individual items immutable. Specifically, if you are passing down an item that array as a prop to another component. Here is how you would do that:
```jsx
const [users, setUsesr] = useState([{ name: "Joseph", email: "joseph.ditton@usu.edu" }, ...])
// ... is not valid sytax here, it just means you might have more that one user

// later in a user action
const newState = [...users];
newState[2] = {...newState[2], email: "newemail@example.com"}; // copy the user and replace them in the state
setUser(newState);
```
* It is preffered to make the whole structure immutable if you can. However, for deeply nested structures that mightb e challenging and ytou can get away with making only parts immutable


