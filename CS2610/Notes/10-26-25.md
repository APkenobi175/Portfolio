# NODE JS


### Rendering Lists of Componenets Dynamically
* We cannot use loops because that is a JS "statement"
* Map is a function we can use.
* Map is a higher order function
* YOu can put in arrays of componenets
```js
return (
	<main>
	{
		
		chatMessages.map((chatMessage)=> {
			return (
				<div key ={chatMessage.id}>
				<div>{chatMessage.message}</div>
				<div>{chatMessage.sender}</div>
				</div>
			)
		})
	}
)
```
* YOu have to specify a special prop on the root element for each "chat message"
* That is where the chatMessage.ID comes in
* The key only needs to go on the top level element
* The key needs to be the outter most element of a list.
* YOu can create an array of elements in another loop
```js
const elements = [];
for (let message of chatMessages){
	elements.push
	***SAME AS ABOVE***
}
```
* This pattern is possible but you will not be seeing it

### CSR VS SSR

* Cclient Side Rendering and Server Side Rendering are two different approaches for rendering web content. With CSR only minimal HTML is sent from the server and then the rest of the UI is created using JavaScript. With SSR the server renders ALL of the HTML into the response to the client and the browser simply displays it. 
* Comparison:
	1. Initial Load Preformance
		* **CSR**
			* Initial page is loaded faster because the server sends a minimal html file along with JS files. The clients browser then fetches the data and renders the page content. 
		* **SSR**
			* The server generates a fully rendered HTML page and includes the content. This means the user gets a complete view of the page on initial load, however it may be slower due to a larger amount of data being sent
	2. SEO (Search Engine Optimization)
		* **CSR**
			* Initially serech engines might have difficuly indexing content generated by JavaScript, potentially affect SEO. 
		* **SSR**
			* SSR Is Generally better for SEO since the fully rendered html is sent to the client. Search engines can easil;y crawl and index this content
	3. User Experience
		* **CSR**
			* Once the initial load is complete and the JS is running subsequence interactions within the website can feel more response because only data is fetched from the server and the page does not fully reload. This means that data can be shared between pages
		* **SSR**
			* Navigating to a new page requires a round trip to the server, this often results in large amounts of data being fetched at once and makes a smooth transition between pages impossible. It also requires a full reload of anything in memory, so if 2 pages rely on the same data then taht data will be fetcfhed once on each parge, reducing preformance 
	4. Complexity and Development Effort
		* **CSR**
			* Developing and maintaining complex user inferfaces in JavaScript can be easier due to the seperation of bnackend and frontend code. However, handling data fetching, state management, and routing on the client side can add complexity
		* **SSR**
			* SSR Requires deeper integration between the front end and back end which an lead to more complex development and deployment processes. However, it can simplify certian aspects like server-side data fetching
	5. Resource Usage
		* **CSR**
			* The clients browser handles most of the rendering work, which can lead to high CPU and memory usage on clients device 
		* **SSR**
			* The server handles most of the rendering work which can lead to increased server load during high traffic periods.
	6. Cachin and Performance Optimization
		* **CSR**
			* Catching strategies can be more complex with CSR due to dynamic data fetching on the client side. Techniques like cline-side caching and service workers can be used to mitigate this
		* **SSR**
			* Caching is often more straightforward with SSR as the server generated HTML can be cached easily, improving preformance
* In Summary the choic between client side and server side rendering depends on the specific needs of your peojct. 
* Many modern web applications use a hybrid approach for optimal user experience
* React is a CSR framework, meanwhile the Django Template Language is an SSR implementation

### Adding Style to React Components
* First you can create a CSS file (index.css)
```css
.chat-message{
	padding: 16px;
	border: 1px solid gray;
	border-radius: 4px;
	box-shadow: 0px 1px 3px rgba(0,0,0,.24), 0px 1px 2px rgba(0,0,0,.12);
}
```
* You cannot use the property called class like you can in HTML in React. 
	* THis is because class is a reserved word in javascript. React ignores it and throws it away
* Instead you need to use the **className** property instead of class on React componenets
	```html
	<div className = "chat-message">
	```
* IN react you don't import your CSS file in HTML.
* YOu import it into your javascript. 
* Import it wherever you define your root (main.jsx)
```jsx
import "./index.css"
```
* And that is how you style with React

* React allows us to style things in an inline way using the style property
```jsx
<div className ="chat-message" style = {{
	fontSize: "3em"
}}>
	<h3>{props.chatMessage.message}</h3>
	<div>{props.chatMessage.sender}<div>
</div>
```


### Conditionally Rendering a Component

* Sometimes you only want to render a component under certian conditions
* There are 2 ways to do this

1. You can return something different using an if statement:
	```
	function App(){
		const [loading, setLoading] = useState(true);
		// ... code that will load the data from the server

		if (loading){
			return <LoadingSPinner />
			
		} else{
			return <HomePage />
		}
	}
	```
2. You can use a ternary expression. This example displays a toolbars for admin if theya re admin and normal user tool bar otherwise
	```
	function App(){
		const [isAdmin, setIsAdmin] = useState(false);
		// ... code that figures out if a current user is an admin

	return (
		<div>
			<header>My App!</header>
			{isAdmin ? <AdminTools /> : <UserTools />}
			<MainPage />
		</div>
	)
	}
	```
	


# NOTES YOU MAY NEED FOR QUIZZES:
# Module 4: Quiz 1 — Notes

### 1. What is Node.js?
**Answer:** A JavaScript runtime that runs natively on the computer instead of the browser.  
**Explanation:** Node.js lets you run JavaScript outside the browser, built on Chrome's V8 engine.

---

### 2. CommonJS Module System
**Valid statements:**
- `module.exports = "Hello, world";`
- `const fs = require("fs");`  
**Explanation:** CommonJS uses `require()` for imports and `module.exports` for exports.

---

### 3. ES Module System
**Valid statements:**
- `export default "Hello, world";`
- `import fs from "fs";`  
**Explanation:** ES Modules (ESM) use `import`/`export` syntax.

---

### 4. Installing Express
**Answer:** `npm install --save express`  
**Explanation:** Modern npm automatically saves dependencies to `package.json`.

---

### 5. What is a React component?
**Answer:** A JavaScript function that returns JSX.  
**Explanation:** Functional components are the standard way to define UI in React.

---

### 6. Rendering a Component with Props
**Question:** How to render `Hello` with name “Joseph”?  
**Answer:** `<Hello name="Joseph" />`  
**Explanation:** Props are passed as HTML-like attributes in JSX.

---

### 7. Passing a Variable as a Prop
**Answer:**
```jsx
const name = "Joseph";
<Hello name={name} />
```  
**Explanation:** Curly braces `{}` inject variables into JSX props.

---

### 8. Displaying a Variable in React
**Answer:**
```jsx
const name = "Joseph";
<div>Hello, {name}</div>
```  
**Explanation:** Use `{}` to embed JS expressions inside JSX.

---

### 9. Key Prop in Lists
**Answer:** `key`  
**Explanation:** React uses the `key` prop to efficiently update lists.

---

### 10. JavaScript Array Transformation
**Answer:** `map`  
**Explanation:** `.map()` loops over an array and returns a new array with transformed values.

---

**Summary:**
- Node.js → JS runtime on computer
- CommonJS → `require` / `module.exports`
- ESM → `import` / `export`
- npm install express → saves dependency
- React component → function returning JSX
- Props use `{}` to inject variables
- Lists need `key`
- Use `map()` to transform arrays
