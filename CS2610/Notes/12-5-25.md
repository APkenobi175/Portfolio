# Combining Vite + React

* When using forms you do not want to use the regular submission process

```jsx
// app.jsx
  async function createNote (e) {
    e.preventDefault (); // Don't submit the form the normal way!
  }
  ```

* You want to handle the submission with JavaScript instead
* You can use the fetch API to make requests to your backend

```jsx
 return (
    <>
      {loading && <div>Loading...</div>}
      {user && <div>Hello {user.first_name}</div>}
      <button onClick={logout}>Logout</button>
      <form onSubmit={createNote} classNamne = "new-note-form">
        Title
        <input type = "text" value={title} onChange = {e => setContent (e.target.value)} />
        Content
        <textarea cols = "30" rows = "10" value={content} onChange = {e => setContent (e.target.value)} ></textarea>
        <button>Save</button>
      </form>
    </>
  )
}
```

* In this example we prevent the default form submission behavior and handle it with the createNote function
* This allows us to make a POST request to our backend to create a new note without reloading the page

Lets create a model for our notes too
```python
# models.py
class Note(models.Model):
    id = models.BigAutoField(primary_key=True)
    title = model.TextField()
    content = models.TextField()
    user = models.ForeignKey(User, on_delete=models.CASCADE)
```

* Now lets run migrations to create the table in the database

```bash
python manage.py makemigrations
python manage.py migrate
``` 

* Ok now lets start with the front end code, remember you don't want to submit the form the normal way because that will reload the page, we will handle it with our own fetch request
* We can do this using the JSON global object to convert our data to a JSON string
* We need to specify the headers too so the backend knows we are sending a JSON datatype, which will go after our data json.stringify call

```jsx
// app.jsx
  async function createNote (e) {
    e.preventDefault (); // Don't submit the form the normal way!
    const res = await fetch ("/notes/", {
        credentials: "same-origin",
        method: "POST",
        data: JSON.stringify ({ // JSON is a global object in Javascript and it reads a string and turns it into a JS object
          title,
          content
        }),
        headers: {
            "Content-Type": "application/json"
        }
    })
  }
  ```

* We are missing one thing though, but lets finish the backend code first in our views.py file, ignore the first three functions, we will add the notes function at the bottom

```python 
# views.py
from django.shortcuts import render, redirect
from django.contrib.auth.models import User
from django.contrib.auth import login, authenticate, logout
from django.http import JsonResponse

from django.contrib.auth.decorators import login_required
import json
from .models import Note

MANIFEST = {}
if not settings.DEBUG:
    with open(os.path.join(settings.BASE_DIR, "frontend", "dist", "manifest.json")) as f:
        MANIFEST = json.load(f)

@login_required
def index(req):
    context = {

    }

# Create your views here.
def sign_up(req):
    if req.method == "POST":
        user = User.objects.create_user(
            username=req.POST.get("email"),
            password=req.POST.get("password"),
            email=req.POST.get("email"),
            first_name=req.POST.get("first_name"),
            last_name=req.POST.get("last_name")
        )
        login(req, user)
        return redirect("/")
    else:
        return render(req, "registration/sign_up.html")

def sign_in(req):
    if req.method == "POST":
        user = authenticate(req, username=req.POST.get("email"), password=req.POST.get("password"))
        if user is not None:
            login(req, user)
            return redirect("/")

        return render(req, "registration/sign_in.html")
    else:
        return render(req, "registration/sign_in.html")

def logout_view(request):
    logout(request)
    return JsonResponse({"success": True })

@login_required
def create_note(req):
    ## to read the body of a post request we use req.body
    ## we need to parse it into a dictionary using the json.loads function
    body = json.loads(req.body)
    note = Note(
        title = body["title"],
        content = body["content"],
        user = req.user

    )
    note.save()
    return JsonResponse({"note": model_to_dict(note)}) # Send back whatever data was newly created, you do not want to re render everything on the server
    # is this going to work? Yes it will!
```
* Now we need to add the url for this view in our urls.py file

```python
# urls.py
from django.urls import path
from . import views
urlpatterns = [
    path("", views.index, name="index"),
    path("sign_up/", views.sign_up, name="sign_up"),
    path("sign_in/", views.sign_in, name="sign_in"),
    path("logout/", views.logout_view, name="logout"),
    path("me/", views.me, name="me"),
    path("notes/", views.create_note, name="create_note"), # New url for creating notes
]
```

* Now we need to fix the front end code to handle the response from the backend
* YOu will use a library that does cookie parsing for you

```bash
npm install cookie --save
```
* Now import it in your app.jsx file

```jsx
import * as cookie from "cookie";
``` 

* Back to our jsx

```jsx
// app.jsx
  async function createNote (e) {
    e.preventDefault (); // Don't submit the form the normal way!
    console.log(cookie.parse(document.cookie)); // this uses our new cookie library to parse the cookies
    const res = await fetch ("/notes/", {
        credentials: "same-origin",
        method: "POST",
        body: JSON.stringify ({ // JSON is a global object in Javascript and it reads a string and turns it into a JS object this needs to be body not data, data is for form data not json
          title,
          content
        }),
        headers: {
            "Content-Type": "application/json"
            "X-CSRFToken": cookie.parse(document.cookie).csrftoken // add the csrftoken header, using our cookie library to parse the cookies This is a custom header that Django looks for to accept the value of the CSRF token
        }
    })
  }
```

* Now lets implement the ability to load the notes from our database
* Lets create a state for our notes

```jsx
    const [notes, setNotes] = useState([]);
```

now inside our createNotes function lets create the body

```jsx
    const body = await res.json();
    setNotes([...notes, body.note]); // add the new note to our notes state

```

* Now lets create a function to get our notes

```jsx
async function getNotes(){
    const res = await fetch("/notes/", {
      credentials: "same-origin", // include cookies!
    });
    const body = await res.body();
    setNotes(body.notes);
}
```

* Then ake sure you call that function in your useEffect

```jsx
  useEffect(() => {
    getUser();
    getNotes(); // get the notes when the component mounts
  }, []);
```

* Now lets fix our views.py file to handle getting the notes

```python
@login_required
def create_note(req):
    if req.method == "POST":
        ## to read the body of a post request we use req.body
        ## we need to parse it into a dictionary using the json.loads function
        body = json.loads(req.body)
        note = Note(
            title = body["title"],
            content = body["content"],
            user = req.user

        )
        note.save()
        return JsonResponse({"note": model_to_dict(note)}) # Send back whatever data was newly created, you do not want to re render everything on the server
    notes = [model_to_dict(note) for note in req.user.note_set.all()] # get all notes for the currently logged in user us list comprehension because Django does not give us a way to dot his because they are dumb
    return JsonResponse({"notes": notes})

```

* Now we can display these

```jsx
      {notes.map((note) => (
        <div key={note.id} className="note">
          <h2>{note.title}</h2>
          <p>{note.content}</p>
        </div>
      ))}
```

* This is in our return statement btw
