# MIPS Arrays

### Annoucements
* Exam 2: November 6 - 8 
* You will be writing some mips code
* some times you'll have to write the whole thing
* sometimes you'll have to fill in the blank
* logic flows, array, functions, nested function
* IEEE754 point conversion as well. so review that bro ham.
* Open books, you can bring his notes (the slides)


### MIPS Arrays

```mips
# Here is an array example
.data
A: .word 5, 8, 2, 9, 1

.text
.globl main
main:
	la $t0, A # base address of array A
	li $t1, 3 # load constant 3 into register $t1
	sw $t1, 0($t0) store 3 into A[0]

	li $t1, 13 # load 3 into register $t1
	sw $t1, 4($t0) #store into A[1] (remember 0 + 4 + 4 + 4)

	$li $t1, 23 # load 23 into register $t1
	sw $t1, 8($t0) #store into A[2] 
```

* Another example:

```mips
la $t0, A # initialize array

li $t1, 3 # load 3 
sw $t1, 0($t0) # store into A[0]

li $t1, 13 # load 23
addi $t0, $t0, 4 # incremenet offset by 4
sw $t1, 0($t0)

li $t1, 23 # load 23
addi $t0, $t0, 4 # incremenet offset by 4
sw $t1, 0($t0)


$li $v0, 10
syscall # exit program
```
* This way you have a variable that keeps track of where you are in the array

### For loops with arrays in MIPS

* Example:
```mips

.data
A: .word 5, 8, 2, 9, 1

.text
.globl main

main:
	la $t0, A # load address of array
	li $t1, 0 # initialize index
	$li $t3, 3 # load constant 3 in $t3

loop:
	bge $t1, 5, skip # loop if index is less than array size

	sw $t3, 0($t0) store into A[i] (offset + (i*4 bytes))

	addi $t1, $t1, 1 # increment index
	addi $t0, $t0, 4 # incremenet offset

	j loop # start of loop

skip:
	li $v0, 10
	syscall # exit program
```
* we are storing the offset in $t0 (4, 8, 12, 16 etc.)

* You can do this in space as well:

```mips
A: .word 5, 8, 2, 9, 1
B: .space 5 # empty array of 5 elements

.text
.globl main

main:
la $t0, A # load address of A
la $t1, B # load address of B

lw $t2, 0($t0) # load A[0]
sw $t2, 0($t1) # store into B[0]

lw $t2, 4($t0) # load A[1]
sw $t2, 4($t1) # store into B[1]
```

1. Set up your initial values, Address of Arrays
2. Initialize your index
3. Set your condition
4. Set up your loop
5. Increment your index, and incremeent your offsets of the arrays (if you load address of the array into a register you incremenet the value in that register by 4)
6. I don't think you need to initiailize the offset
7. jump back to the start of the loop
8. Create your skip function. (exit program)

### Memory Overflow
* Accessing memory you shouldn't have access to 
* If you go outside of the range of your array



