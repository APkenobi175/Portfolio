# Unit 9

### I format Instructions
* Now that we've seen an R format instruction, we will look at the i format.
* I format are all the operations that have constants (addi, li, etc)
* How can we support this in the processor?
* We have constants inside the instruction
* BUt theres a problem instructions only have 32 bits
* We store the constant data in the instruction, not the register file. 
* I format does not use rd (second parameter), does not use shhmt (shifts), and does not use funct. It uses all those 16 bits for the address

* I Format:
	1. First 6 bits are for the operation
	2. 2nd 5 bits are for the first param
	3. 3rd 5 bits are for the storage location
	4. next 16 bits are for the input value
	5. That gives us 32 bits

* Example of I machine code:
	* 001000 00000 00011 0000000000000011
	1. 001000 = addi
	2. 00000 = $zero
	3. 00011 = $3 (Storage location)
	4. 0000000000000011 = 3

* Example 2: lw $3, 4($5)
	* 100011 (lw)
	* 00101 = 4($5)
	* 00000 = $3

* Example 3: sw $5, 8($3)

	1. 101011 = sw operation code
	2. 00011 = register 3 ( parameter register)
	3. 00101 = register 5 ( where its going to be stored)
	4. 0000000000001000 = Constant 8
	5. 101011 00011 00101 0000000000001000

### J Format instructions / Addresses in branches and jumps
	1. Since we are still limited by bits, and addresses are 32 bits there is another way we have to do it. 
	* bne/beq are treated as relative offsets (add to current PC)
	* Treat J as an aboslute value (replace 26 bits of the current PC)

	* Jump Instruction:
		* First 6 bits is the instruction name
		* next 26 is the target address PLUS two zeros (total 28 bits) The last 2 bits are always 00. This is to deal with offset of 4.
		* Our memory registers are 32 bits, which means our addresses will be pointing to instructions in 32 bits. But because the calculations are done in bytes (4 bytes in 32 bits). So when we jump we are jumping by intervals of 4. So because of that the addresses will always have 0s at the end
	* How far can we branch with an immediate
		* -32,768 to 32,767.
		* Branching takes our current 32bit PC, adds 4 to it (00) and then addes sign extend and 16 bit immediate + TWO ZEROS
		* That gives us the next 32 bit PC

	* EVEN THO THE TWO ZEROES are implied, we cannot expand our range using those. Those zeroes are just automatically assumed to be there.


* Example of bne destination
	1. To what address will the following instruction jump when the branch is taken
	2. Currently at address 12
	* bne R0, R1, 16
		* IT will branch to address 80
		* The branch will jump to the current PC plus the immediate TIMES 4 (12 + 16 * 4 = + 4 = 80) current address, plus the branch address times 4, and then an additional 4 more.



* We want to design a new K format instruction for a branch equal immediate
1. What information would need to be encoded ina beq R2, 7, loop instruction
	* Wed need a operation code, a register, and 2 constants
2. Why can't we have a beq R7, 7 loop instruction with our current format
	* None of the R I or J instructions encode 2 constants
	* two 16 bits constants would need 32 bits
3. What tradeoff could we make to implement a k format
	* smaller constants

	
