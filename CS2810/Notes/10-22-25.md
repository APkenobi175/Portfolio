# MIPS Recursion

* The computer can store programs like it can store data

### Recursion
* Recursion is a function that calls itself
* Similar to loops you need a stop condition
* This stop condition is your base case
* When the base case is reached, retturns a value and pops it off the stack

### Review
* Different register types and functions
	* A - Arguments
	* V - return values
	* Zero - 0
	* SP - *stack pointer* <- Important
	* T - Calle saved
	* S - caller saved

### Recursive Functions
* This is not a loop, we are not overwriting our values they are added to the stack
* YOu go through until you hit the base case, then you go backwards and start popping things off the stack
* Example:
```mips
.data
	n: .word 5
	result: .word 0
	msg: .asiiz "Factorial = "

.text
.globl main
main:
	lw $a0, n # load n into $a0 (its an argument)
	jal fact # call factorial function
	sw $v0, result # store the result in memory (V is return value)

	# Print message
	li $v0, 4
	la $a0, msg
	syscall

	# print the result
	li $v0, 1
	la $a0, result
	syscall

	# exit program
	li $v0, 10


fact:
	addi $sp, $sp, -8 # make space on the stack
	sw $ra, 4($sp) # save return address
	sw $a0, 0($sp) # save argument n

	ble $a0, 1, base_case # if n is less than or equal to 1 then return 1 ( jump to base case)

	addi $a0, $a0, -1 # N - 1
	jal fact # recursive call FACT(N-1)

	lw $a0, 0($sp) restore original n
	mul $v0, $a0, $v0 # n * fact(n-1)
	j end_fact 

base_case:
	li $v0, 1 # return 1

end_fact:
	lw $ra, 4($sp) # restore return address
	addi $sp, $sp, 8 # pop the stack
	jr $ra # return to ra (caller)
```




	
