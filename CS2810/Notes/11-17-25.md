# 11-17-25 and 11-19-25 CS2810

## Announcements

* Exam grades tonight
* Everyone did decent

### Processor Speed and Pipelining

#### Critical Path Delay (CPD)

* S-R Flip Flop Gate
* CPD is the longest of all paths
* Ensures all signals can fit within the clock cycle
* THe time in between is called the critical path delay
* The clock should be delayed enough so the signal can go through it all
* The slowest path determines the clock speed, thats our critical path
* Assignment 10 will be pushed back
* Register for final exam soon

#### How to count total delay

* We start at 0 on our inputs
* We get to our first gate, and thats 10ns
* We add our second gate to the total, that gives us 20ns
* Total delay is 20ns
* So, the CPD is 20ns
* So, our clock speed has to be more than 20ns

#### Clock Speed

* 1/CPD and convert it into hertz
* 1/20ns = 50MHz
* So, your clock speed needs to be higher than 50MHz

#### Practice

* When does the signal reach S, Cout, and what is the CPD
  1. S = 40ns
  2. Cout = 45ns
  3. CPD = 1/45ns / 22 mhz

* How long does it take to add and write
  1. 100ns
* HDo we need to include the sign extender logic when calculating the critical path for a processor
  1. Yes
* How long would it take to addi
  1. 45
* How long would it take to add
  1. 40
* How long to beq(tomux)
  1. 45
* How long to lw (to register)
  1. 145
* MAX SPEED
  1. 145

#### Convert NS to Mhz

* ns/10 = Mhz

#### Single Cycle Execution Time

* Slowest instruction determines cycle times because we have to accomadate our longest instruction
* A lot of time is wasted
* BEcause every instruction is of the same cycle time, that creates wasted time
* Possible Solution: Have the fastest instruction determine the clock speed, and let the longest instructions take multiple cycles
  * Much less wasted time
  * However, managing this is very complicated you have to keep track of how long each instructions runs
  * NOT this way.
* Better Solution: Break up instruction into the same set of phases
  * Now the longest phase determines the cycle time
    1. Fetch instruction
    2. Decode instruction
    3. ALU execute
    4. Memory Access
  * BUT, we have to do more cycles per instruction

#### MIPS 5 Stage Pipline

1. Instruction Fetch - IF
2. Decode and read - ID
3. ALU Execute - EX
4. Memory - MEM
5. RF Write back - WB

#### Pipelining to do work in parralel

* Stack instructions in a way that it doesn't tax the CPU more
* Use all parts of the processor for different instructions at the same time
* Aligning the phases so they are never using the same componenets on the CPU, but happen simultaneously.
