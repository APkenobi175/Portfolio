# November 3, 2025

---

## Exam

### Things to know for the exam

1. Exam 2 is on November 6 to november 8, 2025
2. Its at the testing center
3. Material you need to know:
    * IEEE754 Floating Point Conversion as reviewed before
    * MIPS
        * Basic operations
        * Logic flow
        * Arrays
        * Functions
        * Nested functions
        * Understand how to use the register file, move to/from memory
        * no MARS compiler, write MIPS code into answer
        * You will be dealing with stacks and nested functions
4. You are allowed to use the lecture notes
5. If you did the assignment and the quizzes you should be fine (Review assignment and quizzes)

---

## MIPS Circuitry

### Review

* Remember the instruction fetch. It is used by PC to control where to go next

### Examples

1. `beq R1, R2, 10`
    * if R1 and R2 are equal then the ALU will output 1 on the zero which will enable PC src. This means the program counter will not just be incremented 4, it will be PC + 4 + the place we are jumping to. Which we get from the instruction passed through the sign extend.
    * if R1 and R2 are not equal then ALUZero will be 0 which sets PCsrc to 0 which means the program counter is just incremeneted by 4 and does not jump
    * For this beq what PCSrc value determines the next state of the pc memory to jump to. 
        * Answer: 1
2. When is memWrite = 1?
    * Answer: `sw` instructions
    * When we are storing a value in memory
3. When is RegWrite = 1?
    * j-format instructions
    * some i format insructions
4. `sw R2, 4(R0)`
    * We will take R2 information out of the register. And that is the data we want to write. then we will read data from 4(R0) and pump it into the ALU. Since we have the offset number we have to add our immediate 4, and the address R0. That gives us the final address, and that addition takes place in the ALU.
    * Read from R2 and write data in memory
    * calculate offset with the ALU
5. When is ALUSrc = 1?
    * i-format

### Decoding Instructions

1. `add R8, R17, R18` = `000001000110010010000000010000`
    * opcode = 00000 (R code)
    * rs = 10001 (17) (src 1)
    * rt = 10010 (18) (src 2)
    * rd = 01000 (8) (destination)
    * shamt = 00000 (shift)
    * funct = 10000 (function)(add)
2. `addi R8, R17, 23` =  `000011001101001000010000`
    * opcode = 00001
    * rs = 1001 (17)
    * rt = 1010 (8)
    * adress = 01000010000  (23)
3. Decoding
    * Split the instruction up into the logical fields
4. Control
    * Take the opcode and determine what to do with em

### R-format instruction mapping

1. The opcode gets passed into the control mechanism. Decides which instructions to turn on
2. the rs goes into read register 1
3. the rt goes into read register 2
4. the rd goes into write register
5. Question: R format instructions always read from two source registers and write to a destination register
    * **TRUE**

### i-format instruction mapping

1. opcode goes into the controller 
2. rs goges to read register 1
3. rt goes to write register
4. Address gets passed into sign extended and into the ALU
5. All i format instruction write to the register file
    * **FALSE**
    * Example: Branching
    * Only addi and lw write to the register file
    * Some branch out, some write to memory

### Control Line

* A special line that determines if RT will be used as a second register or for the write register
* R-format is register 2
* i-format is write register

### Branch Control Signal

* We use an AND gate to combine:
    1. Branch control signal
    2. Zero output from the ALU
* These are the conditions we need to beq.
* The alu converts other branch instructions to beq!?!??!?!?!?!?!?! apparantly

---