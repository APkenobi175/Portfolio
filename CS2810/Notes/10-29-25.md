# MIPS Datapath

### Review types of instructions
* Data operations
	* Add
	* Subtract
	* Ect

### Program Execution
* Remember how programs are executed (program counter and such)

### MIPS Instructions format
* R - Format: op,rs,rt,rd,shmt,funct
* I - Format: op,rs,rt,address(16)
* J - Format: op, address(26)

### Basic Parts of the process
* Instruction access
* ALU Operations
* Memory Operations

* Control Signals
* MUltiplexers
* Decoding instructions

### Next assignment
* Figure out the logic implementation
* Build and test it

### Single Cycle design
* Our first design will process one isntruction every clock cycle
* THe same idea as how the program counter works
	* Combinational logic generates the next states
	* Memories (flip flops/ RAM) store tje state
	* Clock transfers next state -> current state, and we repeat
* Think about fetch instruction
	* Next State: PC + 4
	* State: program counter (Kind of like a sequencer in ladder logic)

* Your programmer Counter basically just goes to the "next state" after the current state is completed (increment it by 4 unless there is a jump)


### Instruction Fetch
* What does it do?
	* Keeps track of the current instruction address (program counter) in the PC register
	* Increment the PC by 4 on each cycle
	* Load the instruction at the address specified by the PC


## R OPERATION
### ALU Operation 
* What does it do?
	* Read data from the register file (specify rs and rt)(Machine code)
	* Do an ALU operation
	* Write data back to the register file (specify rd) (machine code/output register/where its stored)

* What can we use the zero output from the ALU for? 
	* The output zero is true when the result from the ALU is zero
	* We use this zero for bne/beq instructions. if its 0 no branch if 1 then branch.
* When we write data to the register how many buts are passed
	* 32 bits
	
* What type of instructions ignore the RegWrite input
	* J (jumps) don't need to look at it because we are not writing anything
	* Some i, specifically the store word function. we are writing to memory not the register file.

### Memory Access
* What does it do?
	* Calculate the address
	* Send the address(write:data) to the data memory
	* read: get the results back and put it in the register file

* How does the data memory component interact with the load and store instructions
	* You need to hard code the lw command
	* To store word you first put in an address, write data, and turn memWrite on
	* This is converting mips into circutry

# Putting it All Together
### 4 Componenets
1. ALU Operations
	* Load Instruction
	* calculate the next program counter
	* Read the register file
	* Do the ALU operation
	* Write data back to the register file
2. Memory Access (Load/Store)
	* Load the instruction
	* Calculate the next pc
	* Read the register file
	* Calculate the address
	* Read/Write data the data memory
	* Write data back to the register file
3. Instruction Fetch
	* Load the instruction
	* calculate the next pc
	* Read the register file
	* calculate the branch address
	* Do a branch comparison
	* Update the PC
4. PC Adder
	* Increment PC (used in all the others bruh)

* Most instructions are used in every other one!

* To connect Register File and ALU the ALU result output goes into the write data register input.
* The ALU calculates the address for sw by simply adding 4 to it.
* the magic ALU does is just to add 4 to $t1 in the instruction sw $t0, 4($t1).


### How to merge signals
* Multiplexers
	1. Multiplexer can select the ALU input (register file or sign extended)
	2. Multiplexer can select register file write data (ALU Result or data from memory)
	* THe multiplexers are now controlling which data is going to be sent to the ALU.
* Sign extend
	* Converts it to whatever our input is expecting.
