# 11-21-25 CS2810 Notes

## MIPS 5 Stage Pipeline

* Break down the instructions in different phases to utilize all the CPU, without having to wait.
* THis will use less clock cycles to do the same work

### Breaking up instructions

* Breaking up the instruction into phases, alone this does not provide any benefits
* We only recieve a speed benefit if we stack them together

### Pipelining example 1: Landry

* 4 activities for a load
  1. Washing (1H)
  2. Drying (1H)
  3. Fold (1H)
  4. Put away (1H)

* How long for 4 loads?
  * 4 hours per load = 16 hours
  * We are only utilizing 25% of our time. thats 75% waiting

* Lets try overlapping the activities
  * How long for 4 loads?
    * only 7 hours compared to 16
    * 2.3x faster!
    * 4 Things being done at once

### Pipelinging example 2: Assembly

* Henry ford invented assembly line
* THis pipelined production

* What happens to the efficiency if the pipeline does not stay full
  * C. Goes DOWN.
  * Most inefficient spot at the beginning and end.

### Why Pipelining?

* Increaes our throughput if we can keep the pipeline full
* Our max speed we could do 1 load of laundry in an hour
* IN MIPS we could do 1 instruction per cycle

* OUr latency will always be the same, but the throughput will not

* Pipelining is faster bcause we use all the resources at the same time, but it only works if we keep the pipeline full!

### Why not have a zillion stages?

* Ideally we get an Nx speedup for a pipeline ith N stages
* Why not use a zillion stages to get a zillion x speedup
* Two Problems:
  * Most inscutions cannot be broken down to infinitely small chunks
    * For example, how can we chop up the ALU or the RF
    * Practical limit to logic design
  * There is an overhead for every stage
    * We need to store the state for each stage
    * This requires a register which takes some time
* 5 Phases for mips is the SWEET SPOT

### Pipeline registers and overhead

* Need to store the state for each stage
* Each pipeline stage is combinational logic (think ALU or sign-extension)
* Need pipeline registers between each stage

### Pipeline Clocking

* Clockspeed determined by register => stage => register
  * clock moves data into first register
  * Data goes through the stage combinational: like an adder
  * Data needs to be at next register in time for the net clock

### Ideal pipelins vs Reality

* Not all stages are the same length (not balanced)
  * Reading from a register may be longer than the ALU operation
  * Forces the clock to be slowest stage, which may not be 1/n
* There is overhead for long pipelines
  * Hard to chop up the work
  * pipeline registers take up 5me

* HARD TO KEEP THE PIPELINE FULL

### Question Pipelining Performance

1. HOw much faster can you process a single instruction in a 10 stage pipeline
    * The same speed, and thats because its one instruction so theres nothing to stack

2. How much faster is the throughput of instructions in a 10 stage pipeline
    * 10x the speed theoretically

3. A non pipelined instruction takes 120ns if the instruction is pipelined with 10 stages and pipeline registers take 6ns, what is the overhead of the pipeline registers
    * 33% - Each pipeline takes 120/10 = 12 + 6 which is 18ns per instruction
    * 18ns * 10 = 180 total ns
    * 60ns is 1/3 of 180ns

### MIPS Pipelining phases

1. IF
    * Instruction fetch from memory
2. ID
    * Instruction decode and register read
3. EX
    * Execute operation or calculate address ( heard of the operation)
4. MEM
    * Access memory
5. WB
    * Write back to the register

Pipeline registers go in between each phase. It stores and releases the data whenever there is a rising edge detection on the clock. On each clock cycle the data flows through the pipeline registers. Every clock cycle the data goes to the next phase
