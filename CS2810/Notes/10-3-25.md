# MIPS Assembly Language

### MIPS - What is it?
* MIPS - Microprocessor without interlocked pipeline stages
* We are not at the hardware level anymore. We are att the Abstraction level. This is in between your programming language and the hardware. Assembly
* Now that we've built everything in logism we're gonna actually use those in assembly.
* I will be more abstract in terms of instructions
* The computer memory can store programs just like it can store data
* Programs = data


### Machine Language
* Computer Definition
	* A processor (CPU) that performs operations on a set of register
	* Register File
		* Few
		* COnnected directly at the ALU
		* Quick to access and manipulate
	* Memory Registers
		* Thousands
		* Slow to acces
* When you are preforming calculations you are only working onr egisters in the register file
* Main memory (RAM) can store aninsane amount of information
* RAM must first be loaded into the register file to be utilized
* MIPS is a RISC (Reduced instruction set computer) architechure 
* INstructions are of fixed length (32 bit)
* Three main formats:
	* R-type
	* I-type
	* J-type
* R type register instructions
	* Add, Sub, SLT
	* Example: add 2 numbers, save result in variable $t1
	* add $t1, $t2, $t3
* I Type
	* lw, sw, addi
	* Don't store anything in the register
	* Example: load data in memory address ($sp +4), save it in variable $t0
	```MIPS 
	lw $t0, 4($sp)
	```
* J Type
	* j, jal
	* Example, set program counter to address 10000
	* `j 100000`
	* Kind of like if else?
	* Program counter keeps track of what instruction you want to execute


### Instruction Sets/Examples
* MIPS Instructions
	* Addu, addu, R
	* subgract, subu, R
	* Add immediate, addiu, I
	* load word, lw, I
	* store load, sw, I
	* load byte, lb, I
	* store byte, sb, I
	* load upper immediate, lui, I
	* branch on equal, beq, I
	* branch on not equal, bne, I
	* set less than, slt, R
	* set less than immediate, slti, I
	* jump, j, J
	* jump register, jr, R
	* jump and link, jal, J

* **Examples of MIPS instructions**
	* General 3 operand format:
		* Operator destination, src1, src2 (dest = src1 op src2)
	* Addition
		* add a,b,c (a=b+c)
		* addi a,b,12 (a=b+12) (no register, no storing)
	* Subtraction
		* sub a,b,c (a=b-c)
		* Complex Equations f=(g+h) - (i+j)
		* You must break it into multiple lines
		```MIPS
		add t0, g, h
		add t1, i, j
		sub f, t0, t1
		```


### Registers in MIPS
* 32 General purpose registers
	* R0 - R31 or $0 - $31
	* Each is 32 bits wide
	* we call these 32 bits "words"
	* Values for instructions must come from registers
* Some of these are special
	* R0 or $0 is always zero
	* R29/R31 are used for function calls
* Special registers
	* PC (program counter): Current instruction
	* HI and Lo to store results of multiplication
	* Floating point registers
	* Control registers (for errors and status)
	
### Types of instructions
1. Data operations
	* Arithmetic/Logical
2. Data Transfer
	* Load (Memory to register)
	* Store (Register to Memory)
3. Sequencing
	* Branch (conditional, e.g. <,>, ==)
	* Jump (uncoditional, e.g. go-to, go-toload)

### Operations
* Add - add R1, R2, R3
* Sub - sub R1, R2, R3
* Add immediate - addi R1, R2, C
* Multiply - mult R2, R3 (multiplies two registers and stores results across hi and lo registers)
* Divid - div R2, R3 (same as multiplication stores results across hi and lo registers. Quotient is stored in lo, remainder is stored in hi)
* and - and R1, R2, R3
* or - or R1, R2, R3
* and immediate - andi R1, R2, C
* or immediate - ori R1, R2, C
* shift left logical - sll R1, R2, C (Shifts a register value left by a fixed number of bits)
* shift right logical - srl R1, R2, C (shifts a register value right by a fixed number of bits)

### Data Transfer
	* Load word - lw R1, 145(R2) (Loads a word from memory into a register (stores it into R1))
	* store word  - sw R1, 145(R2) ( stores a word from register into memory)
### Branching
	* Where your if statements are
	* Branch on equal - beq R1, R2, 145 (if R1 and R2 are equal go to program counter address 145)
	* branch on not equal - bne R1, R2, 145 (branches target address if two registers are NOT equal)
	* set on less than - slt R1, R2, R3 ( sets destination register to 1 if one register is less than another (basically testing if its true?))

### Jumps
	* jump - j 145, go to step 145 (unconditional jump to target adress)
	* jump register jr R31 ( go to register R31) ( jumps to address stored in a register)
	* jump and link - jal 145 (jumps to target address and stores return address in register $ra)

### Excercises
	* What is A = B + C in MIPS
		* add A, B, C
		* add $s0, $s1, $s2
	* Load the value from memory address stored in $s3 + 8 into $t0
		* lw $t0, 8($s3) (how many you wanna go forward is just outside the paranthesis)
	* MIPS instruction to branch if $t1 is equal to $t2
		* beq $t1, $t2, address? counter?
