# Registers in MIPS

### 32 General Purpose REgisters
* R0-R31 ($0-$31)
* Each is 32 bits wide. 
* We call thse bits "words"
* values for isntructions must come from registers

### Some are special
* R0 is always zero
R29/R31 are used ofr function call


### Memory
* Memory in MIPS is a large 1D array
* each location is one byte (8 bits)
* For a 32-bit computer, there are 2^32 memory locations (4GB)
* We have 4 memory locations in each register
* 4x8 bits = 32 bits
* Memory = 8 bits wide, register = 32 bits wide


### Access Alignment
* Most data in MIPS is handled in words, not bytes
* A word is 32 bits or 4 bytes
* a word is the size of a register
* Aligned addresses fall on 4 byte boundaries (0,4,8,12,16,20,24,28,32)
* One register can have 4 values in it access it using the 4 byte boundaries

```mips
.data
myVar: .word 11
myVar2: .word 24
myVar3: .word 76
myvar4: .word 123123123
```
* Stores it as Value(+0), Value(+4), Value(+8), etc
* 214748367 is the maximum signed number
* if you add a 1 to it it turns into -214748368
* ONce the first 8 addresses are filled you run out of room so now you have to go to the next row which ends up being the next address.
* So myVar1 is in the ##same register as myVar2

* 32 bits = 1 word
* 1 word = 4 bytes
* 1 byte = 8 bits

### Solution to practice 1
```mips
# define the variables in memory
.data
	x: .word 5
	y: .word 2
	z: .word 3
	result: .space 4 # pointer to adress

.text
globl main

main:

# Load the three variables into the registers
	la $t0, X
	lw $t1, 0($t0)
	lw $t2, 4($t0) # Remember the syntax this means $t4 + 4. Also treat x as the address
	lw $t3, 8($t0) # rember it goes allll the waay  to 32
	

	### Calculate Equation
	sub $t1, $t1, $t2
	add $t1, $t1, $t3
	
```


	


