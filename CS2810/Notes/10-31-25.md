# Machine Code Circuitry

### Control Signals determine Behavior: Addi
* Define Control Signals
	* ALUSrc (ALU Source) and MemtoReg (Memory to Register File)
* Example: What will the ALUSrc be for the addi instruction: addi RS, R0, 10
	* Answer: 1
	* addi takes on operand from the sign-extended immediate field, so the selector needs to be 1
	* remember the constants for i-level isntructions are stored directly in the instruction itself



### Building conditional branch unit
* pc=pc+4
* 1 word, 4 bytes. Each address is 8 bits
* This is how yo get the next instruction

* PC = PC + 4 + [sign extended immediate << 2] if branch
	* remember that we convert our address with the zeroes to the right. so
	* First, shift to the right so we get our zeroes on the end and get the final address

* How to handle branchhing
	* The ALU is used to determine the jump condition
		* On a branch instruction we need to subtract 2 registers and see if the output is 0 to test equality, which we do on the ALU

* When does beq use the ALU output
	* When we have a beq and ALU Zero is true. 
	* If the two registers subtracted = 0 then they are equal.
	* Then the zero flag turns on and thats when we use our zero flag on the ALU.

### Control Signals

* RegWrite
	* 0 Register does not change
	* 1 register is written with data from Write Data
* ALUSrc 
	* 0 Operand 2 comes from register file.
* ALU Operation
	* 0 What operation the ALU performs
*MemRead
	* 0 Tells us if we are reading memorying
*MemWrite
	* 0 Tells us if we are writing to memory
*MemtoReg
	* 0 ALU result flows back to register file
* PCSrc
	* 0 The next PC is PC+4


# Assignment AggieMIPS
