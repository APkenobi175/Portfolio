# MIPS Flow Control

### MIPS Memory Review
* Variable types
	* .word
		1. 32 bits
		2. 4 bytes
		3. 4 memory slots
	* .byte
		1. 1 byte
		2. 4 .bytes is the same as a word. IN memory it looks like 256.
		3. 8 bits
	* .half
		1. 2 bytes
		2. half of a word
		3. Takes up 2 memory slots
		4. two halfs = 1 word

### MIPS Sequencing
* Similar to using labels to store data, we can use lavels to reference lines of code
* We can use the labels to jump around in the program
* These instructions that let us change program control flow
	1. j label: jumps unconditionally to some label
	2. beq $t0, $t1, label: branch if equals, jumps if they are equal
	3. bne $t0, $t1, label: branch if not equals, jumps if parameters not equa
	4. blt $t0, $t1, label: branch if $t0 is less than $t1
	
```mips
.text
.globl main
main:
	li $t0, 1
	li $t1, 2 # Addresses of your labels

adding: # This is a label
	add $t2, $t1, $t0 # Add two values parameters: $t1 and $t0, return value: $t2
```

```mips
li $t0, 1
li $t0
beq $t0, $t1, hello
j goodbyte ### If $t1 == $t2 hello, else goodbye

hello:
	li $v0, 4
	la $a0, helloMsg
	syscall

goodbyte:
	li $v0, 4
	la $a0, GoodbyeMsg
	syscall


### Output: "Goodbye"
```

* This is an example of an if else statement sort of
* Just remember, like ladder logic, the code executes line by line. You can change this sequence by using jumps and labels. JUST LIKE LADDER LOGIC
* with this code if $t0 and $t1 were equal it would output both hellothere and goodbyte
* to prevent this you could put in the goodbye method a jump that skips it if bne $t0 and $t1
* Mimic the return function by putting a jump at the end
* Careful not to make an infinite loop
* Better version
	* Have an exit program method
	* at the end of a method jump to exit_program




	
		
