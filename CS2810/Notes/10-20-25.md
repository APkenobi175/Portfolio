# MIPS Functions and Registers

* Some registers are used for storing values during calculations (temporary variables)
* Some registers are used to control flow of functions
* We can use jump operations but, with more complex workflows we need to keep track of where to return to after a function is called
* We need to make sure we don't over rive registers used by other functions
* USe a stack to keep track of values and push/pop when needed

### A register
* A register is for storing arguments
sum(3,5)
li $a0, 3
li $a1, 5

### V Registers
* V register is for storing return values
* Return temp = move $v0, $t0

### Zero Register
* HArdcoded to 0, always 0
* $zero

### SP - Stack Pointer
* Stack valued in memory

### T Registers - Call Saved
* Called function cal clobber, they can use with no obligation to restore the original value
``` 
temp = a+b
return temp + c

add $t0, $a0, $a1
add $v0, $t0, $a2
```

### S-Registers caller saved
* Functions must perserve value. If changed, they must restore the register to the original value before completing
```
move $t1, 7
move $s1, 7
jar sum
add $t2, $s1, $v0 # $s1 is guaranteed to be 7.
```

### Subroutines
* jal 
	* Jumps to a specific label (Jump somewhere and link back to where you came from)
	* jump and link (jal only remembers the last one so its up to you to keep track of it)
	* The last one is stored in $ra
* jr
	* jump registers 
	* Jumps back to the address that was previously stored in $ra
	* jr $ra


```mips
main:
	addi $sp, $sp, -4 # adjust stack pointer to save return this sets your stack pointer right behind the start of the program
	sw $ra, 0($sp) # this saves the return address $ra into our stack.

	li $a0, 10 # set our arguments
	li $a1, 5 # set our arguments
	jal sum # call sum function


	lw $ra, 0($sp) # after calling the function we need to restore the original return address. Override the old RA with $sp
	addi $sp, $sp, 4 # add the 4 to go back to the starting position (you just popped it off the stack)
	jr $ra # jump back to program counter 0 which is just 0

sum:
	add $v0, $a0, $a1
	jr $ra
```


```mips
main:
	# Arguments...
	li $a0, 3
	li $a1, 5
	# Function call
	jal sumStacked
	move $t0, $v0
	j exit

sumStacked:
	# Allocate space on stack
	# Saves the address to $s0
	addi $sp, $sp, -4
	sw $s0, 0($sp)

	# Save the return address if calling other functions
	# THis is standard convention
	addi $sp, $sp, -4
	sw $ra, 0($sp)

	# Function call
	add $v0, $a0, $a1


	# Restore the return address
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	# Restore saved address
	lw $s0, 0($sp)
	addi $sp, $sp, 4
	# Return to the address
	jr $ra

exit:
	li $v0, 10
	syscall
```



