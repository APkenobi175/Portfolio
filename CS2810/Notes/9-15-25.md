### Combinational Logic
* The type of logic used for building all the gates and chips we saw so far
* The chips current inputs are just sitting there fixed and unchanging
* The chips output is a function of the current inputs and the current input only
* This type of logic is called combinational logic and time independant logic

### Sequential Logic
* The type of logic used for circuits that can "remember"
* The chips output is a function of:
  * Current inputs
  * Previous state
* RAM64k - Final memory product capable of storing 64,000 bytes of information

### INtroducing time
* Time is used to sync everything up
* **Software Needs**
  * The hardware must be able to rememeber things over time
  * The hardware must be able to do things one at a time

* **Hardware needs**
  * THe hardware must handle the physical time delays associated with moving and computing data

* It takes time for inputs to move through logic gates within the ALU
* Until then, the output doesn't mean anything
* This is what the clock is fore
* The clock tells you what the frequency 
* The clock is like a wave and from up to up again is called a "cycle length"
* Its all about making the cycles line up across the entire system
* **Design choices**
  * Set the cycle length to be slightly longer than the maximum time delay
    * Guaranteed to have output at the end of the cycle
    * Observe the output only at the end, ignore what happens within the cycles

### Memory
* Memory is a special type of circuit that holds values and is waiting for it to be read
* YOu load the value, and store it.
* Load memeory into a register
* **The Challange**
  * The challenge here is building chips that realize this functionality
  * Chips are designed to maintain state and change state
* Physical clock
  * An oscillator is used to deliver an ongion train of low-high signals
  * 1mhz electronic oscillator circuit uses the resonant properties of an internal quartz crystal to control the frequency.

### Registers
* Essentially memory slots in your computer.
* CPU registers are internal memory slots (small but fast)
* Designed to store a value until loaded with a new value
* 1 Bit registers
```python
if load(t):
    out(t + 1) = in(t)
else:
    out(t+1) = out
```
* What this code is saying is we're gonna give you signal, t, and next time someones reads its gonna read t+1
* Out always remits registers state
* If you see a load coming in take the input and store it
* Best Practice: After writing, set your load to 0

### Form DFF to 1 Bit Register
* 1 Bit register: Stores one bit at a time
* Similar to the enable/disable from last unit, but instead you are using the clock.
* If there is a load signal then save the input
* The registers value becomes input, the register maintains its current value
* THe load says here I have some data
* The clock says hmm maybe you can accept it maybe not
* It must be syncronized
* The clock is global control, the load is local control.
* The clock is here to SYNCRONIZE!!!!!!!!!!!!!!!!!!!!!!!!!!!
* The output of the multiplexer gets looped around back into it
### Multibit Registers
* Exact same thing but with more bits
* But, we have read and write usage
* we are going to be focusing on 16 bit widths

### Review

* Clock VS Load = Clock gurantees its syncronized and the Load says to take input value and store it, or ignore it. Clock says when you are allowed to do that
* We have the loop here because it is the way it stores the data whenever its not being loaded. So the output doesn't change
* Remember its similating electrical. If you don't loop then it stops and then it resets. it can't stop it must maintain its value and thats why it loops back
* clock is for syncronizing operations 

* THe load is cool



